<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AtCoderコンテストにRustで参加するためのガイドブック</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li><a href="environment.html"><strong aria-hidden="true">2.</strong> AtCoderの環境について</a></li><li><a href="installation/index.html"><strong aria-hidden="true">3.</strong> 開発環境の準備 (TODO)</a></li><li><ol class="section"><li><a href="installation/toolchain.html"><strong aria-hidden="true">3.1.</strong> Rustツールチェインのインストール (TODO)</a></li><li><a href="installation/editor.html"><strong aria-hidden="true">3.2.</strong> ソースコードエディタの準備 (TODO)</a></li><li><a href="installation/rls.html"><strong aria-hidden="true">3.3.</strong> Rust Language Server のインストール</a></li><li><a href="installation/cargo-generate.html"><strong aria-hidden="true">3.4.</strong> cargo-generateのインストール</a></li></ol></li><li><a href="participate/index.html"><strong aria-hidden="true">4.</strong> コンテストの参加方法 (TODO)</a></li><li><ol class="section"><li><a href="participate/before-contest/index.html"><strong aria-hidden="true">4.1.</strong> コンテスト直前の事前準備</a></li><li><ol class="section"><li><a href="participate/before-contest/generate-project.html"><strong aria-hidden="true">4.1.1.</strong> Cargoパッケージの作成 (TODO)</a></li><li><a href="participate/before-contest/choose-crates.html"><strong aria-hidden="true">4.1.2.</strong> 利用するクレートの選択とコンパイル (TODO)</a></li><li><a href="participate/before-contest/copy-project.html"><strong aria-hidden="true">4.1.3.</strong> プロジェクトのコピー (TODO)</a></li></ol></li><li><a href="participate/during-contest/index.html"><strong aria-hidden="true">4.2.</strong> コンテスト開始後の流れ</a></li><li><ol class="section"><li><a href="participate/during-contest/write-tests.html"><strong aria-hidden="true">4.2.1.</strong> テストケースの作成</a></li><li><a href="participate/during-contest/write-program.html"><strong aria-hidden="true">4.2.2.</strong> プログラムの作成 (TODO)</a></li><li><a href="participate/during-contest/test.html"><strong aria-hidden="true">4.2.3.</strong> プログラムのテスト</a></li><li><a href="participate/during-contest/submit.html"><strong aria-hidden="true">4.2.4.</strong> プログラムの提出 (TODO)</a></li></ol></li></ol></li><li><a href="tips.html"><strong aria-hidden="true">5.</strong> Tips（小技集） (TODO)</a></li><li><ol class="section"><li><a href="use-crates.html"><strong aria-hidden="true">5.1.</strong> クレートの使用例</a></li></ol></li><li><a href="atcoder-env/index.html"><strong aria-hidden="true">6.</strong> AtCoder運営者向けの情報</a></li><li><ol class="section"><li><a href="atcoder-env/supported-environment.html"><strong aria-hidden="true">6.1.</strong> 本章で想定している環境</a></li><li><a href="atcoder-env/installation.html"><strong aria-hidden="true">6.2.</strong> インストール</a></li><li><ol class="section"><li><a href="atcoder-env/installing-rust-toolchain.html"><strong aria-hidden="true">6.2.1.</strong> Rustツールチェインのインストール</a></li><li><a href="atcoder-env/installing-rust-crates.html"><strong aria-hidden="true">6.2.2.</strong> クレートのコンパイルとインストール</a></li><li><a href="atcoder-env/installing-rustc-dep-option-generator.html"><strong aria-hidden="true">6.2.3.</strong> （オプション）クレート検索パス生成ツールのインストール</a></li></ol></li><li><a href="atcoder-env/compiling-and-running-program.html"><strong aria-hidden="true">6.3.</strong> コンパイルコマンドと実行コマンド</a></li><li><ol class="section"><li><a href="atcoder-env/compiling-and-running-using-rustc.html"><strong aria-hidden="true">6.3.1.</strong> rustcを利用する</a></li><li><a href="atcoder-env/compiling-and-running-using-cargo.html"><strong aria-hidden="true">6.3.2.</strong> cargoを利用する</a></li></ol></li></ol></li><li><a href="contributors.html"><strong aria-hidden="true">7.</strong> コントリビュータ (TODO)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">AtCoderコンテストにRustで参加するためのガイドブック</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#はじめに" id="はじめに">はじめに</a></h1>
<p>本書はAtCoderのコンテストにRustで参加するためのガイドブックです。</p>
<h2><a class="header" href="#atcoderとは" id="atcoderとは">AtCoderとは？</a></h2>
<p>AtCoderは、オンラインで参加できるプログラミングコンテスト(競技プログラミング)のサイトです。リアルタイムのコンテストで競い合ったり、約3000問のコンテストの過去問にいつでも挑戦することが出来ます。 (<a href="https://atcoder.jp/">AtCoderのトップページ</a>より引用)</p>
<blockquote>
<p>Note: 競技プログラミングはプログラミングで解決できるような問題をなるべく早く正確に解く競技です。競技プログラミングについてよく知らないが興味があるという方は、インターネット上に初心者向けの詳しい情報がたくさんありますので検索してみてください。AtCoderで開催されているものでは、大きく分けて二種類あります。</p>
<ul>
<li>与えられる問題に対して、その解を出力するようなプログラムを書く競技 (アルゴリズム系)
<ul>
<li>定期開催のもの: AtCoder Beginner Contest (ABC), AtCoder Regular Contest (ARC), AtCoder Grand Contest (AGC) があり、難易度は通常 ABC &lt; ARC &lt; AGC です。</li>
<li>定期開催の他、企業によって開かれるコンテストもあります。そういったコンテストで上位成績をとると、その企業への就職、インターン、アルバイトなどで多少優遇されることがあります (コンテストによります) 。</li>
<li>例: 「整数<code>N</code>が与えられます。<code>N</code>以下の正整数から等確率に1つを選ぶとき、それが奇数になる確率を求めなさい」 (AtCoder Beginner Contest 142 A問題)</li>
<li>例: 「<code>N</code>人の身長が与えられます。<code>K</code>cm以上の人の人数を出力してください」 (AtCoder Beginner Contest 142 B問題)</li>
</ul>
</li>
<li>与えられる問題に対して、少しでも良い解を出力するようなプログラムを書く競技 (マラソン系)
<ul>
<li>定期開催のものはまだありません。企業が自社の取り組みやそこでの課題をテーマに出題することが多いようです。</li>
<li>例: 「ある観測データが与えられるので、可能な限り圧縮するプログラムとそれを解凍するプログラムを書いてください」 (Wethernews Programming Competition)</li>
</ul>
</li>
</ul>
</blockquote>
<h2><a class="header" href="#なぜrustなのか" id="なぜrustなのか">なぜRustなのか？</a></h2>
<p>AtCoderで使える言語は非常にたくさんあります。どの言語を使ってもよいですし、問題によって使い分けても構いません。その中でなぜRustを使うのか、そのメリットとデメリットをまとめてみました。できるだけ一般論で比較するよう心がけますが、競技プログラミングにおけるC++人口がそれなりに多いことと、Rustはその特性上C++と比較されることが多いので、具体的にC++との比較になっている部分も多くあります。</p>
<h3><a class="header" href="#メリット" id="メリット">メリット</a></h3>
<h4><a class="header" href="#高速である" id="高速である">高速である</a></h4>
<p>AtCoder含め、競技プログラミングでは「実行時間制限」とよばれるものがあります。この時間内にプログラムの実行が終わらないと「TLE (Time Limit Exceeded)」という判定が付いて誤答扱いとなります。多くの場合は想定されている解法であれば多少の余裕をもって解けるように設定されていますが、非常にたくさんの言語が使える都合上全ての言語で公平になるようにはできません。遅い言語に合わせて設定すると速い言語では強引な解法でゴリ押しできてしまうことがありますし、速い言語に合わせると遅い言語では想定されている解法でも通せないということになります。いずれにせよ、基本的には速い言語であるほうが計算時間的には有利です。 (もちろん遅い言語と言われるものにも、例えば書き易さであったり、ライブラリが充実していたり、なにかしらのメリットがあるはずです。どちらかが絶対的に有利ということではありません。)</p>
<p>Rustは最速と言われるC/C++並みに速いとされていますので、(少なくともAtCoderでは) 速度面で不利になることはないと言えるでしょう。</p>
<h4><a class="header" href="#信頼性が高い" id="信頼性が高い">信頼性が高い</a></h4>
<p>信頼性は、ここではRustの<a href="https://www.rust-lang.org/">公式トップページ</a>に倣いメモリ安全性、スレッド安全性、バグの起こしにくさであるとします。競技プログラミングで特に大事になってくるのはメモリ安全性とバグの起こしにくさです。</p>
<blockquote>
<p><strong>Reliability</strong> Rust’s rich type system and ownership model guarantee memory-safety and thread-safety — and enable you to eliminate many classes of bugs at compile-time.</p>
</blockquote>
<p>これは様々なプログラミング言語が様々なアイデアで対処している部分です。たとえばメモリの確保と解放を正しく行うために、C++であればスマートポインタやコンテナを用意したり、他の言語ではガベージコレクタという実行時の機構を用意したりしています。RustでもC++のスマートポインタやコンテナと同様なものを用意し、自分でメモリの確保と解放を行わなくてよいようにできています。ガベージコレクタを利用すると確かに安全でメモリ管理に関してほとんど何も考えなくてよいものの、そのためにほとんどのデータをヒープに置いて参照経由で扱わなければならず、実行速度にも多少影響します。かといってC++のスマートポインタやコンテナは間違った使い方が簡単にできてしまいます。特にイテレータはコレクションに対する操作を行うための標準的なツールにもかかわらず実質的に単なるポインタと同様なので、しばしば無効なイテレータが発生します。例えば (少々意図的な例ですが) 次のように簡単に問題を起こせてしまいます。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std::string_literals;
int main() {
    std::vector&lt;std::string&gt; v = {&quot;hello&quot;s, &quot;world&quot;s};
    v.shrink_to_fit();
    for (auto const &amp;i: v) {
        if (i == &quot;hello&quot;) v.push_back(&quot;c++&quot;s); // イテレータを無効化してしまう
        // 未定義動作なので、プログラム全体が何を起こすか分からない
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}
</code></pre>
<p>このようなことはRustではコンパイルエラーとしてコンパイル時に検出されます。</p>
<pre><code class="language-rust ignore">let mut v = vec![&quot;hello&quot;, &quot;world&quot;];
for &amp;i in &amp;v {
    if i == &quot;hello&quot; {
        v.push(&quot;rust&quot;);
        // E0502: cannot borrow `v` as mutable because it is also borrowed as immutable
        // 4 | for &amp;i in &amp;v {
        //   |           --
        //   |           immutable borrow occurs here
        //   |           immutable borrow later used here
        // 5 |     if i == &quot;hello&quot; {
        // 6 |         v.push(&quot;rust&quot;);
        //   |         ^^^^^^^^^^^^^^ mutable borrow occurs here
    }
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>また、複雑なアルゴリズムにバグはつきものです。例えば、添字計算をしていてちょっとした書き間違いで配列のサイズを超えたところを参照してしまったといったことは度々起こりえます。こういうとき、例えばC/C++では配列外参照をしてしまったプログラムがどのように動作するかの保証がなく、<code>segmentation fault</code>とだけ表示されて異常終了したり、たまたまうまくいってしまったり、手元で正解するケースがサーバーでは誤答となったりし得ます。こういったよく分からない動作が起きてしまうとバグの原因特定が難しくなったり無関係なところを原因と思い込んだりしてしまい、デバッグにかなりの時間を費やしてしまうこともしばしばあります。この配列外参照の例ではRustは必ずエラーを起こしますし、どこで起こしたかも表示してくれます。それが自分のコードでない場合でも (<code>-g</code>オプション付きでビルドされたかCargoでデバッグビルドされたバイナリであれば) バックトレースを表示させることで呼出元となる自分のコードを特定できます。</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let x = vec![1, 2, 3];
let y = 3;
let _z = x[y]; // 配列外参照!
#}</code></pre></pre>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3', ...
stack backtrace:
  (...中略...)
  16: alloc::vec::{{impl}}::index&lt;i32,usize&gt;
             at ...
  17: test::main
             at .\test.rs:4
  (...中略...)
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<h4><a class="header" href="#多くの問題をコンパイル時に発見できる" id="多くの問題をコンパイル時に発見できる">多くの問題をコンパイル時に発見できる</a></h4>
<p>RustはC/C++並みの速度を確保するため、実行時にやらなければいけないことをなるべく減らす方針の言語です。たとえば先ほど触れたように、多くの言語にあるガベージコレクタがありません。それだけならばC++と変わりありませんが、速度と安全性を両立させるためにRustではできるだけ多くのことをコンパイル時に確認する仕組みになっています。C++が受け入れてしまうような危険なコードもコンパイルエラーにします。</p>
<p>それ以外にも、例えば整数型同士の暗黙の型変換がない (例え<code>u8</code>から<code>u32</code>であっても) こともある種のミスを防ぐのに役立ちます。たとえばC++で総和をとるために<code>accumulate()</code>関数を利用する際、気をつけなければオーバーフローしないはずのところでオーバーフローを起こしてしまいます (もし符号付き整数型であったなら未定義動作にもなってしまいます) 。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main() {
    // long long で表せる最大値を`large`とする。
    long long large = std::numeric_limits&lt;long long&gt;::max();

    std::vector&lt;long long&gt; s = {large};

    // sには`large`しか入っていないので、総和は普通に`large`になるはず。ところが
    // 総和の型をint型だと思って計算してしまいオーバーフローを起こしてしまう。特
    // に何のエラーもなし。
    std::cout &lt;&lt; std::accumulate(s.begin(), s.end(), 0) &lt;&lt; std::endl;

    // 正しくは以下の通り。
    std::cout &lt;&lt; std::accumulate(s.begin(), s.end(), 0ll) &lt;&lt; std::endl;
}
</code></pre>
<p>Rustではこのようなことは最初から型の不一致によりコンパイルエラーとなります。</p>
<pre><code class="language-rust ignore">let s = vec![std::i64::MAX];
let x: i32 = s.into_iter().sum();
// E0277: the trait bound `i32: std::iter::Sum&lt;i64&gt;` is not satisfied
// 3 | let x: i32 = s.into_iter().sum();
//   |                            ^^^ the trait `std::iter::Sum&lt;i64&gt;` is not implemented for `i32`
</code></pre>
<p>ジェネリクスとトレイトの仕組みも強力です。たとえばジェネリックな関数が型変数<code>T</code>をもつとき、この<code>T</code>のとりうる型を特定のトレイト (＝機能一覧) を実装しているものだけに制限することができます。逆に<code>T</code>に対してできることはその特定のトレイトが定める機能のみです。従って、一度コンパイルが通った関数はその制約を満たす限りのどのような<code>T</code>を与えても関数の内部でコンパイルエラーとなることはありません。特にライブラリを整備するにあたってはこれはとてもありがたいことです。実際に使ってみなくても、コンパイルさえ通れば、将来的に作られうるどんなユーザー定義型を与えようともその関数が正しく呼び出せることが保証されます。C++のテンプレートなどでは実際に具体的な型を与えて始めて様々な検証をするので、使う段階になってからでないとエラーが発見できません。このことは、後述するコンパイルエラーの分かりやすさにも繋がっています。</p>
<h4><a class="header" href="#コンパイルエラーが分かりやすい" id="コンパイルエラーが分かりやすい">コンパイルエラーが分かりやすい</a></h4>
<p>これは少々主観的な話になるのかもしれませんが、Rustのコンパイルエラーは読みやすく分かりやすいという評判があります。実際にコンパイルエラーが発生したとき、まずエラーが起きた場所はもちろんとして、エラーが関連する他の場所 (例えば以前に借用された場所など) などをアスキーアート的な手法で視覚的に分かりやすく表示してくれます。さらに、なぜそれが間違っているのか/それをどのように修正することができるかのヒントが提示されることもあります。例えば、先ほどのエラー全体は次のようになっていました。</p>
<pre><code class="language-console">error[E0277]: the trait bound `i32: std::iter::Sum&lt;i64&gt;` is not satisfied
--&gt; (filename):3:32
|
3 |     let x: i32 = s.into_iter().sum();
|                                ^^^ the trait `std::iter::Sum&lt;i64&gt;` is not implemented for `i32`
|
= help: the following implementations were found:
            &lt;i32 as std::iter::Sum&lt;&amp;'a i32&gt;&gt;
            &lt;i32 as std::iter::Sum&gt;

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>先ほど少し触れたように、トレイト/ジェネリクスの仕組みによりエラーの所在が明確化されています。関数が呼び出せないのは引数に関数が設定した制約を満たさないものを与えているからだと分かります。動的型付け言語やC++のテンプレートでは、仕組み上実際に実行または実体化してみなければエラーの存在が分かりませんので、与えられた引数が関数の求める条件を満たしていなかったのか関数の方に根本的な書き間違いがあるのかがインタプリタ/コンパイラには分かりません。必然的に実際にエラーを起こしたライブラリの内部の実装部分を指し示しながら、ここで呼び出されていて、ここで呼び出されていて、...と辿っていくしかなく、しかもそのうちのどれが悪いのかが分からないので関係がありそうなところを全て表示していくしかありません。</p>
<p>一部のエラーには詳細な説明が用意されており、<code>rustc --explain (エラーコード)</code>とすることにより、そのエラーが何を言っているのか/どういうコードでそのエラーが発生するのかなどをもりこんだ詳細な解説を読むこともできます。たとえば上のエラーの<code>E0277</code>にも用意されています。</p>
<pre><code class="language-console">$ rustc --explain E0277
You tried to use a type which doesn't implement some trait in a place which
expected that trait. Erroneous code example:

```
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}
```
(以下略)
</code></pre>
<h4><a class="header" href="#抽象化のための機能を数多く備えている" id="抽象化のための機能を数多く備えている">抽象化のための機能を数多く備えている</a></h4>
<p>例えば次のようなさまざまな機能があります。Rustは後発の言語ですので、他のプログラミング言語に備わっている優れた機能も参考にして多数の機能が導入されています。</p>
<ul>
<li>
<p>強力な型推論</p>
<p>型推論アルゴリズムとしては非常に有名なHindley/Milnerのアルゴリズムをベースにした賢い型推論器を持ちます。言語設計的に型推論を制限している箇所 (例: 関数の引数) や、型推論だけでは決定できず型を明示する必要があることもあります (例: <code>iter.collect::&lt;Result&lt;_, _&gt;&gt;()?</code>) 。それでもほとんどのケースでは推論され、型の明示は最低限で済みます。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">代数的データ構造</a></p>
<p>Rustの列挙型 (<code>enum</code>)は各バリアントに値を持てます。いわゆる直和型や代数的データ型と呼ばれるものです。タグ付き共用体 (tagged union) と呼ばれることもあります。例えば一方向連結リストの構造は次のように表せます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum List&lt;T&gt; {
    /// 先頭要素とそれ以降の要素によるリストを持つ。
    Cons(T, Box&lt;List&lt;T&gt;&gt;),

    /// リストが空であることを示す。
    Nil,
}
#}</code></pre></pre>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">トレイト</a></p>
<p>JavaやC#のインターフェイスと似ていますが、より柔軟に利用することができます。Rustではいわゆる「オブジェクト指向言語」が持つ継承の仕組みをもたない代わりに強力な列挙型とトレイトの仕組みを活用します。例えば単純な継承関係であれば次のような方法で置き換えられます。多くの場合、1.と2.を用いれば十分対応できることでしょう (<a href="https://twitter.com/i/web/status/928550702720233472">参考</a>) 。</p>
<ol>
<li>
<p>実装クラスが数個かつパラメータも多くはない</p>
<p>列挙型 (直和型)を使います。
むしろこのような場合は最初から継承よりも直和型が適切である場合が多いです。
実際、KotlinやScalaではJVM上で抽象クラスとそのサブクラスを直和型のように扱うためにsealed classという機能を備えています。</p>
</li>
<li>
<p>実装の共有</p>
<p>トレイトのデフォルト実装を使います。
フィールドの共通化は、代わりにgetterメソッドをトレイトに記述しておきます。
むしろこれにより各フィールドやメソッドの役割が明確になり、無意味に複雑なコードが生まれにくくなります。</p>
<p>ただし、getterを書く際に「1つのオブジェクトに対する可変参照は高々1つしか存在できない」という原則が障害となることがごく稀にあります。</p>
</li>
<li>
<p>特定のメソッドだけ必要</p>
<p>trait object (<a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code>Box&lt;_&gt;</code></a>)でdynamic dispatchを行ないます。</p>
</li>
</ol>
<p>なお、<a href="https://doc.rust-lang.org/stable/std/?search=Deref"><code>Deref</code></a>と<a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>トレイトを実装すると、メソッド呼出時に自動的に対象の型への型変換が行われ、簡単に対象の型のメソッドを呼び出すことができるようになります。これを継承における「親クラスからのメソッドの受け継ぎ」に転用することは可能ですが、これはアンチパターンとされることも多いです (<a href="https://github.com/rust-unofficial/patterns/blob/master/anti_patterns/deref.md">参考</a>) 。</p>
<p>その他また、Rustのトレイトは型クラスのように考えることもできます (<a href="https://keens.github.io/slide/katakurasuwokoete/">参考</a>) 。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching">パターンマッチング</a></p>
<p>パターンマッチングは、端的に言うならばタプルや構造体・列挙型などを (構造に合わせて分岐しながら) 分解し、中身を取り出す機能です。特に先に触れた列挙型を扱うにあたっては、パターンマッチは非常に強力な機能です。最近でも少しずつ改善が行なわれており、 Rust 1.26で<a href="https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html">slice pattern</a>が追加されたり1.39で<a href="https://github.com/rust-lang/rust/pull/63118/"><code>if</code>の制限の取り払われたり</a>しました。これらの改善もあり、特にML系言語に馴染みのある方は近い感覚で扱えるのではないでしょうか。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch19-06-macros.html"><strong>衛生的</strong>マクロ</a></p>
<p>衛生的とは識別子が衝突する心配がないことです。マクロ内で宣言されたローカル変数がマクロ外から参照できてしまうことも、その逆にマクロ内で参照する変数がたまたま展開先のローカル変数を参照してしまうこともありません。また、マクロの各引数が何を受け取るのかを指定することができるため、例えば式を受け取ると指定すればその引数はひとまとまりの式として扱われます。この式の値を利用するときに、前後の関係で式としての解釈が壊れることもありません (例えば <code>$x = 1 + 2</code> のとき <code>2 * $x</code> は <code>2 * 1 + 2</code> ではなく <code>2 * (1 + 2)</code> に相当します) 。</p>
<p>このように、Rustのマクロは積極的に利用しても比較的安全です。特にRustでは多くなりがちなボイラープレートを短くまとめるなど役に立つ機会も多いでしょう。またマクロの入力はパターンマッチで行われるため受け付ける文法が比較的自由であり、この後に述べるRustのデメリットのうち特に冗長性に関わることは可読性を保ったままマクロで解決できることも多いです。</p>
</li>
<li>
<p>block expression</p>
<p>block expression とはブロックを式として扱える仕組みのことです。ブロックの式としての値はそのブロックの末尾にある式の値になります。これがあると、例えば別の変数の初期化にしか使わない一時変数のスコープを絞ることができます。地味ではありますが、あると便利に感じる機能です。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">シャドーイング (の推奨)</a></p>
<p>一般的にシャドーイングはすべきでないとされる傾向がありますが、Rustではむしろシャドーイングが推奨されています。
これにより、たとえば処理の途中で一度変数に格納するときにもわざわざprefixやsuffixが付いた別の変数を宣言しなくて良くなりますし、あるいは再束縛することで不要になった<code>mut</code>を消すこともできます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// この配列を数値にしてかつソートしたい
let list = vec![&quot;2&quot;, &quot;4&quot;, &quot;1&quot;, &quot;5&quot;, &quot;3&quot;];
let list = list.into_iter().map(|x| x.parse().unwrap());
// ソートしたいので mut とする
let mut list: Vec&lt;i32&gt; = list.collect();
list.sort();
let list = list; // ソートしたので mut は不要、消す
// list.push(4); // =&gt; 既に mut ではないので変更できない
assert_eq!(list, [1, 2, 3, 4, 5]);
#}</code></pre></pre>
<p>一般にシャドーイングするべきではないとされる理由は様々にありますが、一番はやはり混同しやすくなるからと考えられます。その点Rustは強い静的型付け言語ですので、仮に混同したとしてもどこかのタイミングで型エラーになるという期待ができます。</p>
<p>また、変数の個数を抑止するという効果もあります。block expression等と適宜組み合わせることで変数の数やスコープはさらに小さく保つことができ、多少関数の実装が長くなっても見通しが悪くなりにくいと言えます。競技プログラミングではmain関数が長くなりがちなので一層嬉しいのではないでしょうか。</p>
</li>
</ul>
<h4><a class="header" href="#ゼロコスト抽象化を追求している" id="ゼロコスト抽象化を追求している">ゼロコスト抽象化を追求している</a></h4>
<p>Rustの言語デザインやライブラリは、一定の使いやすさを実現しつつも、使いやすさのために実行時の高速性を犠牲にはしないという<strong>ゼロコスト抽象化</strong> (<em>zero-cost abstraction</em>)を追求しています。</p>
<p>他の言語では「イテレータではなくfor文で書いた方が速い」、「async/awaitを使うと遅い」といったことは珍しくありません。これはその言語の選択で、動作が遅くなるとしてもコードを簡潔に簡単に書けることを優先したと言えます。一方でRustでは抽象化によってパフォーマンスが犠牲になるのなら、その抽象化はできるだけ採用しません。最適化の余地 (自由度) を残すためには関数群は基礎的なものにとどめる必要があり、特定の機能を実現するために冗長なコードを書く必要があります。結果的にコードは長く面倒になり手間もかかりますが、そうしてでもパフォーマンスをとることができるように設計されています。</p>
<p>このことは「簡潔な構文や関数によってその機能が必要とするコストを隠してしまう」ことを避けているとも言えます。つまり、本当にパフォーマンスが必要なときに最適化を検討するべき「コスト」の部分が明確化されているということでもあります。</p>
<h3><a class="header" href="#デメリット" id="デメリット">デメリット</a></h3>
<h4><a class="header" href="#現れる概念が比較的難しい" id="現れる概念が比較的難しい">現れる概念が比較的難しい</a></h4>
<p>先に見たように、Rustでは、いままで他の言語ではコンパイラが検証していなかったようなことをコンパイル時に検証します。そのためにRustでは所有権や借用をはじめとする独特の概念が導入されており、それらの概念の理解そのものが難しいとされることも多いようです。これらの概念が課す多数のルールがなぜ存在するのかを理解することは、仕組みをある程度理解していなければ難しいものです。</p>
<p>たとえば要素への参照をもったまま<code>Vec</code>本体の可変参照をとることはできませんが、これは可変参照と共有参照は同時に存在できないというルールからです。ではなぜこのようなルールがあるのでしょうか。たとえば<code>Vec</code>に要素を追加するとキャパシティが足りないときにメモリの再確保とデータの移動が行われるので、無効な参照が生み出せてしまうからです。しかしこういった事情を知らないと、単にRustがよく分からない制約を課してくるだけの書きにくい言語だと感じてしまうかもしれません。一方でこの難しさを隠せている言語もあります。たとえばJavaやC#などオブジェクトを参照で扱うような言語では、要素への参照を得ても単にそのオブジェクトへの参照が一つ増えるだけで、可変長配列の領域そのものへの参照を得るわけではないということもあるかもしれません。そのような言語では、要素そのものは可変長配列が管理するメモリ上にあるわけではないので、要素への参照をもったまま可変長配列を伸ばしても問題は起こりません。そのかわり、おそらく別の部分の犠牲 (アクセスに必ず参照を介することのコストであったり、参照型と値型の挙動の違いによる難しさであったり) があります。</p>
<p>Rustが課すルールにも理由がありますので、そういった事情について意識的に考えることは他の言語や競技プログラミング以外の文脈でも活きる有意義なものではあると思います。単にAtCoderである程度の競技プログラミングをするだけであれば、C#やJavaといった言語でもほぼ正解できるよう調整されているようなので、どちらを取るかは好みといっていいかもしれません。</p>
<h4><a class="header" href="#素早く書くことにはあまり向かない仕様" id="素早く書くことにはあまり向かない仕様">素早く書くことにはあまり向かない仕様</a></h4>
<p>Rustの安全指向や標準ライブラリの設計方針などは、時間をかけて大規模なプログラムを書くときや堅牢なプログラムを書くときには非常に役に立ちます。一方で競技プログラミングでは、一般のプログラミングと異なり、次のような特徴があります。</p>
<ul>
<li>早くプログラムを完成させることが重要</li>
<li>入力のフォーマットや扱う値の範囲・個数などが定まっている</li>
<li>スレッドを起動してやりとりするようなことは通常ない</li>
<li>後日提出したプログラムを見直したり保守することは通常ない (ライブラリを除く)</li>
</ul>
<p>したがって、Rustの様々な設計は、必要以上に煩雑に感じることがあります。例えば、Rustでの競技プログラミングを始めようとした方で、標準入力をとるのがとても面倒で挫折し (かけ) た、という方も度々見かけます。例えば、空白区切り二つの整数を読み取ってその和を計算するプログラムは、工夫をしなければ次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn main() {
    let (a, b) = {
        let mut s = String::new();
        std::io::stdin().read_line(&amp;mut s).unwrap();
        let mut iter = s.split_whitespace().map(|i| i.parse::&lt;i32&gt;().unwrap());
        (iter.next().unwrap(), iter.next().unwrap())
    };

    println!(&quot;{}&quot;, a + b);
}
</code></pre></pre>
<p>「二つの空白区切りの数字を読むだけでこれほど多くのコードが必要なのか」と思われるかもしれませんが、こうなっているのには次のような設計があります。</p>
<ul>
<li>空白区切りの入力を任意の型の値として読み込むことができない。
<code>std</code>には整数を読む機能などはなく、かならず一行単位 (<code>read_line()</code>) または全体 (<code>read_to_string()</code>) を文字列として読んでから処理する必要があります。なお<code>read_to_string()</code>を使うときは、<code>use std::io::Read;</code>が必要であることと、手元でテストするときにEOF (<code>Ctrl + D</code> (macOSやLinux) または<code>Ctrl + Z</code> (Windows)) を入力するまで入力が終了しないこと、に注意が必要です。</li>
<li>入力はバッファをとって、そこに書き込む。
<code>read_line(&amp;mut s)</code>の部分にあたります。入力を<code>String</code>に入れて返す関数よりも、バッファを受けとって書き込む方式の方が、必要に応じてバッファを事前にアロケートしておける分、パフォーマンス的には柔軟なのです。とはいえ競技プログラミングでは高々O(log n)回のリアロケーション (この挙動はドキュメント化されていないため変わる可能性もなくはありませんが) にかかるコストを気にする必要はないと思われます。</li>
<li>イテレータを上手に扱う必要がある。
受け取った文字列を空白区切りにするためには<code>split_whitespace()</code>という関数を使いますが、これはイテレータを返します。その各要素を整数に変換するために<code>map()</code>と<code>parse()</code>関数を使いますが、変換先の型を指定するために<code>parse::&lt;i32&gt;()</code>などの書き方を使う必要があります。<a href="https://crates.io/crates/itertools"><code>itertools</code></a> を使えば<a href="https://docs.rs/itertools/0.8.2/itertools/trait.Itertools.html#method.next_tuple">イテレータを直接分解するような書き方ができますが</a> 、<code>std</code>に限れば一つずつ<code>next()</code>で要素を取り出すしかありません。</li>
<li><code>std</code>を含む各ライブラリは大抵明示的なエラーハンドリングを要求する。
<ul>
<li>何かの理由で標準入力が読み込めない状態になるかもしれません。整数ではない入力を整数にしようとするかもしれません。イテレータの要素が足りないかもしれません。こういったものをRustでは<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a>や<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>で表現します。<a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><code>?</code></a>を使えば視認性を損ねることはない (むしろコードを俯瞰するときのの助けになる) ですが競技プログラミングでは<code>unwrap()</code>を使うことになるでしょう。これはエラーが起きたならパニック (i.e. <code>RE</code>) するという乱暴なものですが、入力の形式が決まっている以上エラーになるのは読み間違えたか書き間違えたときのみでしょう。</li>
<li>もちろん逆に、明示的なエラーハンドリングは要求しないかわりに失敗時は内部でパニックするような関数もあります。
例えば<a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code>Index</code></a>で境界外アクセスしたときやメモリが足りずにアロケーションに失敗したとき、<a href="https://doc.rust-lang.org/std/macro.println.html#panics"><code>println!</code>が失敗したとき</a>にパニックします。
このように「失敗するとパニックする」ものはその条件をドキュメントに<code># Panics</code>という形で書いています。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: 入力をとる方法については、2020年言語アップデートで外部クレートとして<a href="https://docs.rs/proconio/0.3.6/proconio/"><code>proconio</code></a>や<a href="https://docs.rs/text_io/0.1.8/text_io/"><code>text_io</code></a>, <a href="https://docs.rs/whiteread/0.5.0/whiteread/"><code>whiteread</code></a>などのクレートが導入されたため、かなり改善されました。リンク先はそれぞれのクレートのドキュメントになっていますので、詳しくはそちらをご覧ください。</p>
</blockquote>
<p>他にも、先程少し触れましたが例えば数値型の四則演算や比較を行なうときには基本的に両辺の型が等しくなければいけません。
<code>i32</code>と<code>&amp;'_ i32</code>を両辺に持って来ることくらいは許されていますが<code>i32</code>と<code>i64</code>をそのまま足したり比較したりはできません。
片方を明示的に変換する必要があります。
これは型システムの都合等ではなく数値型に対しては意図的に制限されています。</p>
<p>さらにスライスのインデックスは<a href="https://doc.rust-lang.org/stable/std/slice/trait.SliceIndex.html"><code>usize</code>及び<code>usize</code>の範囲</a>でなくてはなりません。
<code>isize</code>では駄目です。
競技プログラミングでは、非負整数として入力される値であっても、計算途中では符号付き整数の方が扱いやすいので符号付き整数として扱うことが多々あります。その場合<code>arr[(添字の計算式) as usize]</code>のように<code>usize</code>に戻す必要があります。
実際AtCoderの提出のうち、<code>&quot;as usize&quot;</code>という部分文字列を持つRustのコードは結構な数が存在します。
地味なところですが、動的計画法など添字を多用するところでは面倒に感じるかもしれません。</p>
<p>一般的には危ないのでコンパイラが許してくれないものの、使い方の制限に照らせば問題ない動作をしたいということもありえます。たとえば<a href="https://qiita.com/tanakh/items/d70561f038a0ef4f0ff1">こちら</a>では二次元配列 (<code>Vec&lt;Vec&lt;T&gt;&gt;</code>) における要素の交換を実装しようとしていますが、同じ要素に対する二つの可変参照を持てないというルールによって普通に実装することができません。競技中に「あ、これがやりたい」と思ったことが必ずしもスムーズに実装できない場合がありえます。</p>
<p>Rustで参加する競技プログラマーの中には、こうした煩雑さを改善するためのマクロやヘルパ関数 (もっと便利に標準入力がとれるようにするなど) を定義し、テンプレート (ひな型) として用意している方もいます。インターネット上で公開されている方もいらっしゃいますし、過去のコンテストでの上位Rust参加者の提出などをのぞいてみると、いろいろと参考になるかもしれません。</p>
<h4><a class="header" href="#標準ライブラリが小さい" id="標準ライブラリが小さい">標準ライブラリが小さい</a></h4>
<p>Rustは比較的新しい言語ですので、インターネット接続環境を前提にしたパッケージ管理システムCargoを標準で持ちます。このため、言語の成長とクレートやRustエコシステムの成長を分離することを目的に、Rustは標準ライブラリを最低限の抽象化とインターフェースとして位置付け、できるだけ小さく保ち続けてきました。かつて標準ライブラリの一部だったり本体にバンドルされていたライブラリ (<code>num</code>, <code>rand</code>, <code>regex</code> など) を積極的に分離することさえしています。ユーザーはCargoを使えば、使いたいパッケージを<a href="https://crates.io">crates.io</a>からいつでも自由にダウンロードできます。</p>
<p>しかし、逆に言えば標準ライブラリだけでは使える機能が非常に制限されるということにもなります。そのため、2020年言語アップデートでいくつかの著名な外部クレートが導入されて利用できるようになりました。2020年4月6日現在、利用可能なクレートの一覧とそれぞれについての簡単な説明が<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/2020-Update">こちら</a>にまとめられています。</p>
<h4><a class="header" href="#コンパイル時間が長くなりがち" id="コンパイル時間が長くなりがち">コンパイル時間が長くなりがち</a></h4>
<p>様々な解析をコンパイル時に行う都合上、コンパイル時間が長めにかかる傾向があります。Rustではコンパイル速度を速くすることはあまり重要視されていません。特に手元で提出をテストする際、外部クレートを利用するならその外部クレートのビルドも実行することになります。二回目以降のビルドではビルドキャッシュを利用するためコンパイルする必要はありませんが、初回の実行では利用する外部クレートによっては数分単位の時間をとられる可能性があります。つまり、素早く書き上げたコードを手元で軽く実行してみることにすら時間をとられてしまい、提出時刻が数分遅れてしまうということがあり得ます。結果的に手元でコンパイルが通るかどうかをチェックする時間すら惜しいとなってしまうと本末転倒です。なお、外部ライブラリを含むパッケージをコンテスト開始前に一回ビルドしておいて、競技時はそのフォルダをコピーして編集するというふうにすれば回避できます。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#atcoderの環境について" id="atcoderの環境について">AtCoderの環境について</a></h1>
<p>現在 AtCoder で利用できる最新の環境は 2020 年言語アップデートによって更新された環境です。</p>
<ul>
<li>Rust 1.42.0</li>
<li>外部クレートあり</li>
</ul>
<p>コンパイルオプションや利用できる外部クレートの一覧と簡単な解説やコード例など、この環境についてのより詳しい情報は <a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/2020-Update">2020 Update</a> のページにまとまっています。ご一読ください。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#開発環境の準備" id="開発環境の準備">開発環境の準備</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>この章では、手元のパソコンに Rust の開発環境と、テキストエディタとして <a href="https://code.visualstudio.com/">Visual Studio Code</a> をインストールする方法について説明します。</p>
<p>環境を手元に用意するメリットは普段使い慣れたエディタや環境でコーディングできるようになることです。開発環境を用意して Language Server Protocol に対応するエディタ (<a href="https://code.visualstudio.com/">Visual Studio Code</a> など) を利用すれば、入力補完やリアルタイムのエラーチェックなど様々な機能の恩恵を受けることができます。逆に言うと、自分の使い慣れたエディタや環境を使いたいと思わずむしろ環境を整える方が面倒だと感じられる方は AtCoder のコードテスト (TODO: リンクが完成次第挿入) を利用するのが最も簡単な方法です。外部ライブラリにまつわる互換性の問題もありません。</p>
<p>既に Rust の開発環境がインストールされており、普段使い慣れたエディタや編集環境もあるという方には前半は全く不要な話となります。<a href="installation/cargo-generate.html"><code>cargo-generate</code> のインストール</a>へお進みください。それもインストールされている方はこの章で説明することはありませんので、実際に<a href="installation/../participate/index.html">参加方法の説明</a>へお進みください。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#rust-ツールチェインのインストール" id="rust-ツールチェインのインストール">Rust ツールチェインのインストール</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<blockquote>
<p>Note: インストール方法は適宜変わる可能性があります。情報が古いまたは不足している場合は、公式の <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">book</a> にある解説を適宜参照ください (英語) 。</p>
</blockquote>
<p>まずは Rust 本体をインストールする必要があります。</p>
<h2><a class="header" href="#ステップ-1-rust-に必要になる依存関係を追加する" id="ステップ-1-rust-に必要になる依存関係を追加する">ステップ 1: Rust に必要になる依存関係を追加する</a></h2>
<p>OS によっては Rust を実行するのに追加のプログラムが必要になりますので、まずはそれをインストールしましょう。</p>
<ul>
<li>
<p>Windows</p>
<p>(TODO: Visual Studio Build Tools をインストール)</p>
</li>
<li>
<p>macOS</p>
<p>(TODO: Cコンパイラ (に付属するリンカー) のインストール)</p>
</li>
<li>
<p>Linux (Windows Subsystem for Linux を含む)</p>
<p>(TODO: Cコンパイラ (に付属するリンカー) のインストール)</p>
</li>
</ul>
<h2><a class="header" href="#ステップ-2-rustup-のインストールスクリプトを実行する" id="ステップ-2-rustup-のインストールスクリプトを実行する">ステップ 2: Rustup のインストールスクリプトを実行する</a></h2>
<p>OS によっては標準のパッケージ管理に Rust のパッケージが存在することもありますが、ここでは Rustup という Rust のバージョン管理プログラムを通してインストールすることを前提とします。このプログラムを使うと、最新版へのバージョンアップや特定のバージョンのインストールがコマンド一つで実行できます。また、そのようにしてインストールされた複数のバージョンの Rust を簡単に使い分けることができます。</p>
<p><a href="https://rustup.rs/">https://rustup.rs/</a> にアクセスすると、お使いのプラットフォームに合わせてインストールスクリプトを実行する方法が表示されます。大きくは Windows と macOS/Linux で分かれます。</p>
<ul>
<li>
<p>Windows</p>
<p><code>rustup-init.exe</code> のような実行ファイルのダウンロードリンクが示されていると思いますので、それをダウンロードして実行します。</p>
</li>
<li>
<p>macOS / Linux (Windows Subsystem for Linux 含む)</p>
<p><code>curl</code> を用いてスクリプトをダウンロード・実行する方法が示されていると思います。書かれているコマンドをターミナルへ入力してください。</p>
</li>
</ul>
<p>(TODO: 以下、スクリプトの指示に従ってインストールする方法とインストールを確認する方法を書く)</p>
<h2><a class="header" href="#ステップ-3-インストールされたことを確認する" id="ステップ-3-インストールされたことを確認する">ステップ 3: インストールされたことを確認する</a></h2>
<p>インストール終了後、 Windows の方はコマンド プロンプト、 macOS または Linux の方は端末を開き、次のように入力してみましょう。次のようにバージョン情報が表示されればインストールは完了です。もしコマンドが見つからない、のようなエラーメッセージが表示される場合は、環境変数がまだ反映されていない可能性があります。一度再起動をして、もう一度試してみてください。</p>
<pre><code class="language-console">$ rustc --version
rustc 1.42.0 (b8cedc004 2020-03-09)
</code></pre>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#ソースコードエディタの準備" id="ソースコードエディタの準備">ソースコードエディタの準備</a></h1>
<p>Rust プログラムのソースコードは単純なテキストファイルです。編集にはテキストエディタというプログラムを使います。単純にテキストを読み書きするという機能に限ればテキストエディタは OS にも付属していますが、よりプログラミングに特化した機能を多く揃えるテキストエディタが無料で簡単に使える時代ですので、ぜひ活用するべきです。それらのエディタが持つ機能には例えば次のようなものがあります。 (一例です)</p>
<ul>
<li>コードハイライト<br />
文法構造に合わせてソースコードを色付けして表示する機能です。たとえば型名や関数名などに色がつきます。この機能はコードを視覚的に把握するのに役立ちます。</li>
<li>入力補完<br />
変数名や関数名の最初の何文字かを入力するだけでそれから始まる要素を列挙して表示してくれます。目当てのものがあればキー一つで残りの部分を補完してくれます。</li>
<li>エラーハイライト<br />
入力するのと同時にリアルタイムに内容をチェックし、エラーがあればそれをエディタ上に赤線を引くなどの形で表示してくれます。コンパイラを直接実行する手間もエラーメッセージを読み解く手間もなくエラーに気づくことができるメリットがあります。</li>
<li>ドキュメント (説明書き) の表示<br />
久しぶりに使う関数の引数の数や順番がわからなくなることはよくあることですが、こういうときにマウスカーソルを関数に合わせるだけでその関数のシグネチャやドキュメントを表示してくれます。</li>
<li>定義へのジャンプ<br />
その関数や型が定義されている場所を開いてくれます。構造体の中身を少し忘れてしまったり、関数の処理の中身を確認したりといったときに簡単にソース上を移動できます。</li>
</ul>
<p>こういった機能は Language Server Protocol という共通の仕組みの上に実装されているので、これをサポートするエディタであればこれらの機能を享受できます。 Language Server Client を実装しているエディタは無数にあり、どれを使うかは完全に好みです。</p>
<p>本説明はできるだけエディタによらないように進めていくつもりですが、エディタに特有の内容が現れるときは <a href="https://code.visualstudio.com/">Visual Studio Code</a> を想定して説明します。それ以外のエディタを使われる方は適宜読み替えてお読みください。次節で Rust のコーディング支援機能を導入する方法を説明します。</p>
<p>(TODO: Visual Studio Code のインストールと Rust (rls) 拡張機能のインストールを説明する)</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#rust-language-server-のインストール" id="rust-language-server-のインストール">Rust Language Server のインストール</a></h1>
<p>Rust Language Server (RLS) は、ソースコード編集中の様々な支援機能を提供するためのプログラムです。例えば、プログラムを編集しながらリアルタイムでエラー箇所をハイライトしたり、コード補完機能を提供したり、定義にジャンプしたり、簡単なドキュメントを表示したりといった様々な機能があります。使い慣れたエディタとともにこうした支援機能が使えることが、ローカルに Rust の環境を作る大きなメリットです。</p>
<p>なお、こうしたコーディング支援機能が不要だと考える方はインストールをする必要はありません。</p>
<blockquote>
<p>Note: Visual Studio Code を利用している方は、拡張機能が自動的にインストールしてくれるため、ここで直接インストールする必要はありません。</p>
</blockquote>
<p>さて、 RLS は Rust 本体と同時に配布されているため、 RLS のインストールをする前に対応するバージョンの Rust をインストールしなければなりません。現在 AtCoder で使える Rust のバージョンは 1.42.0 ですので、コマンド プロンプトあるいは端末を開いて次のようにコマンドを実行します。</p>
<pre><code class="language-console">$ rustup install 1.42.0
info: syncing channel updates for '1.42.0-x86_64-pc-windows-msvc'
info: latest update on 2020-03-12, rust version 1.42.0 (b8cedc004 2020-03-09)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
 12.0 MiB /  12.0 MiB (100 %)   5.9 MiB/s in  1s ETA:  0s
info: downloading component 'rust-std'
info: downloading component 'rustc'
 35.6 MiB /  35.6 MiB (100 %)  28.2 MiB/s in  1s ETA:  0s
info: downloading component 'rustfmt'
info: installing component 'cargo'
info: installing component 'clippy'
info: installing component 'rust-docs'
 12.0 MiB /  12.0 MiB (100 %)   2.4 MiB/s in  4s ETA:  0s
info: installing component 'rust-std'
info: installing component 'rustc'
 35.6 MiB /  35.6 MiB (100 %)  10.7 MiB/s in  3s ETA:  0s
info: installing component 'rustfmt'

  1.42.0-x86_64-pc-windows-msvc installed - rustc 1.42.0 (b8cedc004 2020-03-09)

info: checking for self-updates
</code></pre>
<p>続けて RLS をインストールします。なお必要なコンポーネントは変わるかもしれませんので、適宜 <a href="https://github.com/rust-lang/rls">RLS のリポジトリ</a>も参照してください。</p>
<pre><code class="language-console">$ rustup component add --toolchain 1.42.0 rls rust-analysis rust-src
info: downloading component 'rls'
info: installing component 'rls'
info: downloading component 'rust-analysis'
info: installing component 'rust-analysis'
info: downloading component 'rust-src'
info: installing component 'rust-src'
</code></pre>
<p>両方の実行が完了すれば、 RLS のインストールは終了です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#cargo-generate-のインストール" id="cargo-generate-のインストール"><code>cargo-generate</code> のインストール</a></h1>
<p>AtCoder で利用できる Rust のバージョンやライブラリを指定したプロジェクトを簡単に生成するために、 <a href="https://github.com/rust-lang-ja/atcoder-rust-base/tree/ja">atcoder-rust-base の ja ブランチ</a>にプロジェクトの雛形を用意しています。この雛形は<code>cargo generate</code>というコマンドを使って展開するため、先にこのコマンドをインストールする必要があります。</p>
<p><code>cargo generate</code> サブコマンドを利用できるようにするには <code>cargo-generate</code> が必要です。端末 (Windows ユーザーの方はコマンド プロンプト) を開いて <code>cargo install cargo-generate</code> コマンドを実行してください。これだけでインストールは完了です。</p>
<pre><code class="language-console">$ cargo install cargo-generate
    Updating crates.io index
Downloaded cargo-generate v0.5.0
(...中略...)
    Compiling cargo-generate v0.5.0
    Finished release [optimized] target(s) in 5m 46s
Installing ...
    Installed package `cargo-generate v0.5.0` (executable `...`)
</code></pre>
<p>実際に <code>cargo generate --help</code> として実行できるかどうかを確認しましょう。</p>
<pre><code class="language-console">$ cargo generate --help
cargo-generate 0.5.0
Ashley Williams &lt;ashley666ashley@gmail.com&gt;
cargo, make me a project

USAGE:
    cargo generate [FLAGS] [OPTIONS] --git &lt;git&gt;

FLAGS:
    -f, --force      Enforce to create a new project without case conversion of project name
    -h, --help       Prints help information
    -V, --version    Prints version information
    -v, --verbose

OPTIONS:
        --branch &lt;branch&gt;
        --git &lt;git&gt;
    -n, --name &lt;name&gt;
</code></pre>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コンテストの参加方法" id="コンテストの参加方法">コンテストの参加方法</a></h1>
<p><strong>TODO</strong> この章は書きかけです。</p>
<p>本章では、手元にAtCoderのジャッジサーバーの環境と同等のプロジェクトを用意してコンテストに参加する方法について説明します。</p>
<p>ここでは、現在AtCoderで提供されている環境と同じ環境を使って手元でもコーディングできるようにするための最低限の汎用的な方法をなるべく標準的な方法で解説しています。実は、より競プロやAtCoderへの参加に特化したツールというものもあり、インターネットを検索するといくつも見つけることができます。これらのツールには、テストケースをAtCoderから自動でダウンロードしてテストしたり、自作ライブラリを自動で埋め込んで提出できる形に整形したり、そのツールから直接提出できたりするようなものも存在します。ここではそういったツールのご紹介はしませんが、競プロに慣れ、本格的に取り組んでみようと考え始めるようになれば一度検討してみるのもよいかもしれません。もちろん既存のツールを使わずに、自分にとって最も参加しやすいスタイルを新しく確立するのも面白いことです。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コンテスト開始前の事前準備" id="コンテスト開始前の事前準備">コンテスト開始前の事前準備</a></h1>
<p>コンテストの開始前にプロジェクトを準備して一度ビルドしておくと、コンテスト開始後の動きがスムーズになります。特に初回ビルド時は依存クレートのコンパイルに時間がかかります。お使いのパソコンのスペックにもよりますが、もしすべてのクレートを有効にした場合は完了まで数分程度かかるとお考えください。</p>
<ol>
<li>作業するためのプロジェクトを作成します。</li>
<li>使いそうなクレートを有効化し、一度プロジェクトをビルドしておきます。</li>
<li>プロジェクトを問題数分だけコピーしておきます。
<ul>
<li>好みに応じて一つのプロジェクトを使い回すのでもかまいません。</li>
</ul>
</li>
</ol>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#プロジェクトを生成する" id="プロジェクトを生成する">プロジェクトを生成する</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>まずは AtCoder サーバーと同じ環境のプロジェクトを手元に準備します。</p>
<p>まずは、今から参加するコンテストのソースコードを置くフォルダを準備してください。</p>
<p>(TODO: フォルダを作成してそこに cd する方法を説明する)</p>
<p>では、実際にプロジェクトを生成していきます。</p>
<h2><a class="header" href="#cargo-generate-をインストールしている場合" id="cargo-generate-をインストールしている場合"><code>cargo-generate</code> をインストールしている場合</a></h2>
<p><code>cargo generate</code> コマンドをインストールしている場合は、次のようにコマンドを実行してプロジェクト名を入力すれば AtCoder での環境と同様の環境のプロジェクトが生成できます。</p>
<pre><code class="language-console">$ cargo generate --git https://github.com/rust-lang-ja/atcoder-rust-base --branch ja
Project Name: abc000
Creating project called `abc000`...
Done! New project created /path/to/project/abc000
</code></pre>
<p>これで表示されているパスにプロジェクトが生成されました。</p>
<blockquote>
<p>Note: ここで生成されるプロジェクトはサンプルとして <a href="https://atcoder.jp/contests/abc086/tasks/arc089_a">AtCoder Beginner Contest 086 C - Traveling</a> の解答例とサンプルケースのテスト方法例が書かれてます。テンプレートを自分向けにカスタマイズしたい場合は、リポジトリをフォークするなどして編集し、それを URL に指定して生成させることもできます。</p>
</blockquote>
<h2><a class="header" href="#cargo-generate-をインストールしていない場合" id="cargo-generate-をインストールしていない場合"><code>cargo-generate</code> をインストールしていない場合</a></h2>
<p>まずは空のプロジェクトを作成します。</p>
<pre><code class="language-console">$ cargo init abc000
     Created binary (application) package
</code></pre>
<p>そして <code>abc000/Cargo.toml</code> の <code>[dependencies]</code> 以下に AtCoder で利用できるライブラリを追加してください。 <a href="https://github.com/rust-lang-ja/atcoder-rust-base">atcoder-rust-base</a> の <a href="https://github.com/rust-lang-ja/atcoder-rust-base/tree/ja">ja ブランチ</a> に含まれている Cargo.toml の雛形を参考にできます。ただしこれは <code>cargo-generate</code> 用の雛形のためプロジェクト名など一部の項目がプレースホルダになっており、そのまま使えるものではないことに注意が必要です。もし完全な形の Cargo.toml をお探しなら、 <a href="https://github.com/rust-lang-ja/atcoder-rust-base/tree/ja-all-enabled">ja-all-enabled ブランチ</a> に有効な形の Cargo.toml が含まれていますので、こちらを利用することもできます。</p>
<p>また、 Rustup を利用している場合、プロジェクトディレクトリに <code>rust-toolchain</code> というファイルを置いて中身に <code>1.42.0</code> とだけ書いておくと、 <code>cargo</code> などのツールを呼び出したときに自動的に Rust 1.42.0 のツールチェインを利用してくれます。もしそのツールチェインがインストールされていなければ自動でダウンロードが始まり、インストールされます。この先しばらくして Rust のバージョンアップが進み、再び AtCoder 側のバージョンとの乖離が大きくなってきたときは、間違って 1.43 以降にしか存在しない機能を利用してしまって Compilation Error を受けないためにも強制的に 1.42.0 を利用させるのが便利です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#利用するクレートの選択とコンパイル" id="利用するクレートの選択とコンパイル">利用するクレートの選択とコンパイル</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>先にも軽く触れた通り、依存クレートのコンパイルにはそれなりの時間がかかります。コンテストが始まってから最初の問題の提出前に実行するとなるとそれなりのタイムロスになります。そこで次の二つのことをコンテスト開始前に行ってしまい、コンテスト開始後になるべくスムーズに行動できるよう準備しておきましょう。</p>
<h2><a class="header" href="#利用するクレートの選択" id="利用するクレートの選択">利用するクレートの選択</a></h2>
<p>これは事前準備時間を短くする、またはビルドディレクトリのディスク容量を減らすことに効果があります。</p>
<p>すべての依存クレートを有効化すると、スペックや環境にもよりますが、初回のコンパイルに数分かかるようになり、ビルドキャッシュも数百 MB (メガバイト) になります。ただし二回目以降のコンパイル時間やコンパイル後のバイナリの実行速度には影響しません。すなわち、競プロとして AtCoder 上で不利になるようなことはありません。したがって、最初にすべてのクレートを有効にしてしまったほうがコンテスト中の自由度は高くなります。このあたりのバランスはご自分のパソコンのリソースと相談して選択してください。</p>
<h2><a class="header" href="#事前コンパイル" id="事前コンパイル">事前コンパイル</a></h2>
<p>利用するクレートの選択を終えたら、次は事前コンパイルを行います。</p>
<p>(TODO: コマンド プロンプトまたは端末を開き、プロジェクトのあるフォルダまで移動する方法を説明する)</p>
<p>端末を開いてプロジェクトのあるフォルダまで移動したら、次のようにビルドを行います。</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
   Compiling proc-macro2 v0.4.30
   Compiling unicode-xid v0.1.0
   Compiling syn v0.15.39
   Compiling lazy_static v1.3.0
   Compiling quote v0.6.12
       :
       :
    Finished dev [unoptimized + debuginfo] target(s) in 20.27s
</code></pre>
<p><code>Finished</code> の文字が見えたら、依存クレートのコンパイルは完了となります。</p>
<blockquote>
<p>Note: ここでは <code>cargo build</code> としてデバッグモードでのビルドを行いました。実際の AtCoder では <code>--release</code> オプションをつけて実行速度を最適化するのですが、これをつけるとさらにビルド時間が伸びてしまうことや、デバッガによるデバッグがしづらくなることなどのデメリットがあります。加えて、手元の環境ですることはサンプルケースレベルの比較的小さいサイズの入力を試す程度であることが多いため、速度を最適化する必要性もさほどないことが多いのではないでしょうか。一方、手元でもリリースビルドでテストすることがあるという方は、この段階で <code>cargo build --release</code> も加えて実行しておくことをおすすめします。そうでないとコンテスト中にリリースビルド用の依存クレートのコンパイルが行われ、多くの時間を取られてしまいます。</p>
</blockquote>
<h2><a class="header" href="#オプション-rust-language-server-の事前準備" id="オプション-rust-language-server-の事前準備">(オプション) Rust Language Server の事前準備</a></h2>
<blockquote>
<p>Note: この手順は Rust Language Server (RLS) を利用しない方は必要ありません。</p>
</blockquote>
<p>RLS は <code>cargo build</code> とは別にキャッシュを持っており、初回起動時にキャッシュを作成します。したがって今の状態のプロジェクトは <code>cargo build</code> については十分高速に実行できますが、プロジェクトを開いてから補完などが機能するまでには時間がかかってしまうということです。したがって、このキャッシュについても今のうちに作っておくと、開いた直後から快適な編集ができます。</p>
<blockquote>
<p>Note: 最近は RLS の後継 (RLS 2) として開発されている Rust Analyzer という Language Server もあります。 <a href="https://github.com/rust-analyzer/rust-analyzer">GitHub のリポジトリ</a>によればまだ開発段階とのことですが、以前に比べ機能も揃ってきています。不具合や課題もまだまだあるとはいえ、特にレスポンス面では Rust Language Server を超えている部分も多く見られます。この説明では正式版の RLS を採用しますが、導入方法もだんだんと整備されて簡単になっていますので、興味のある方はぜひお試しください。Visual Studio Code であれば拡張機能を一つインストールするだけです。</p>
</blockquote>
<p>実際にキャッシュを作る方法は、単に今作成したプロジェクトを開くだけです。以下では Visual Studio Code の場合に説明しますが、他のエディタを利用する場合はそれに合わせて行ってください。</p>
<ul>
<li>
<p>プロジェクトを開きます。</p>
<p>もし対応するバージョンの RLS がインストールされていない場合は、次のようなダイアログが右下に表示されます。ここで Yes を選択すれば自動的に RLS がインストールされます。</p>
<p><img src="participate/before-contest/rls_install_prompt.png" alt="RLS is not installed. Install?" /></p>
</li>
<li>
<p>ステータスバー左側の様子をチェックします。</p>
<p>開いた当初は、くるくる回るインジケーターとともに Starting と表示されています。</p>
<p><img src="participate/before-contest/rls_starting.png" alt="RLS Starting" /></p>
<p>しばらくするとくるくる回りながらビルドが始まります。右側には現在ビルドしているクレートが表示されます。</p>
<p><img src="participate/before-contest/rls_building.png" alt="RLS Building" /></p>
<p>それが終わると、くるくる回るインジケーターが消えて RLS とだけ表示される状態になります。</p>
<p><img src="participate/before-contest/rls_finish.png" alt="RLS" /></p>
<p>この状態になれば RLS の準備は完了です。</p>
</li>
</ul>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#プロジェクトのコピー" id="プロジェクトのコピー">プロジェクトのコピー</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>競プロで書くコードは書き捨てにする、という方は先程作ったプロジェクトをすべての問題で使いまわしても問題ありませんが、コードをずっと残しておきたいとか、あるいは詰まったから一旦保存しておいて別の問題に行きたいことがよくある、といった事情で、プロジェクトを予め問題数分用意しておきたい方もいるかと思われます。この作業も少々手間ですので、このようにされたい方はコンテスト前に準備しておくとよいでしょう。</p>
<p>もっとも簡単で確実なのは、プロジェクトをそのまままるごとコピーすることです。容量に不安のない方はそれで構いません。しかし数百 MB に及ぶプロジェクトをそのままコピーすることは時間も負担もかかりますし、リソース的に難しいという方もいると思います。多くの容量を占めるのは <code>target/</code> 以下であり、しかもほとんどは全く同一のビルドキャッシュになります。そこでこの <code>target</code> フォルダをシンボリックリンクにしてしまい、実体は一つにしてしまうという手があります。 (TODO: Linux と macOS での動作確認をする)</p>
<p>方法は、コピーするときに <code>target</code> フォルダだけ除外してコピーしておき、コピーされた各プロジェクトの中に、先に除外した <code>target/</code> フォルダを指すようなシンボリックリンク (Windows の場合、ジャンクションでも構いません) を作成します。</p>
<ul>
<li>
<p>Windows</p>
<p>(TODO: ジャンクション (<code>mklink /J target /path/to/original/target</code>) または (必要ならローカルセキュリティポリシーまたはレジストリエディタを使って SeCreateSymbolicLinkPrivilege 権限を有効にして) シンボリックリンク (<code>mklink /D target /path/to/original/target</code>))</p>
</li>
<li>
<p>macOS または Linux</p>
<p>(TODO: <code>ln -s /path/to/original/target target</code>)</p>
</li>
</ul>
<p>ただし、このときはメインバイナリ <code>target/debug/&lt;project-name&gt;</code> すらも共有になってしまうため、別のプロジェクトを <code>cargo run</code> する前に <code>cargo clean -p &lt;project-name&gt;</code> としてバイナリを削除する必要があります。 <code>cargo</code> はおそらくソースファイルとバイナリの更新日時を比較してリビルドの要不要を判断しているため、状態によっては前のプロジェクトの成果物をそのまま実行してしまうことがあります。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コンテスト開始後の流れ" id="コンテスト開始後の流れ">コンテスト開始後の流れ</a></h1>
<ol>
<li>問題を開き、テストケースを記述します。</li>
<li>プログラムを書きます。</li>
<li>テストします。</li>
<li>プログラムを提出します。</li>
</ol>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#テストケースの作成" id="テストケースの作成">テストケースの作成</a></h1>
<p>Rust には組み込みでテストをするための機構が備わっています。これらの様式に則ってテストを書くと、 <code>cargo test</code> コマンドを実行するだけでテストを実行することができます。これを競プロでもサンプルケースが通るかどうかを確かめるのに利用することができます。この機能の使い方の例として、生成したテンプレートの <code>tests/sample_inputs.rs</code> には <a href="https://atcoder.jp/contests/abc086/tasks/arc089_a">AtCoder Beginner Contest 086 C - Traveling</a> のサンプルケースが書かれています。</p>
<blockquote>
<p>Note: 直接手と目で確認する場合や、別のコンテスト支援ツールを利用する場合などはこの手順は必要ありません。また <code>cargo test</code> を利用しない場合、サンプルのテストファイルは削除しても良いですし、しなくても特に問題はありません。</p>
</blockquote>
<p>なんとなく見れば分かるように、 <code>output_with_stdin()</code> の引数にサンプル入力を渡し <code>assert_eq!(output.stdout_str(), &lt;expected output&gt;);</code> で期待する出力と一致するかどうかを確かめます。一致しない場合、テストは失敗します。</p>
<pre><code class="language-rust ignore">use cli_test_dir::*;

const BIN: &amp;'static str = &quot;./main&quot;;

#[test]
fn sample1() {
    let testdir = TestDir::new(BIN, &quot;&quot;);
    let output = testdir
        .cmd()
        .output_with_stdin(r#&quot;2
3 1 2
6 1 1
&quot;#)
        .tee_output()
        .expect_success();
    assert_eq!(output.stdout_str(), &quot;Yes\n&quot;);
    assert!(output.stderr_str().is_empty());
}

#[test]
fn sample2() {
    let testdir = TestDir::new(BIN, &quot;&quot;);
    let output = testdir
        .cmd()
        .output_with_stdin(r#&quot;1
2 100 100
&quot;#)
        .tee_output()
        .expect_success();
    assert_eq!(output.stdout_str(), &quot;No\n&quot;);
    assert!(output.stderr_str().is_empty());
}

#[test]
fn sample3() {
    let testdir = TestDir::new(BIN, &quot;&quot;);
    let output = testdir
        .cmd()
        .output_with_stdin(r#&quot;2
5 1 1
100 1 1
&quot;#)
        .tee_output()
        .expect_success();
    assert_eq!(output.stdout_str(), &quot;No\n&quot;);
    assert!(output.stderr_str().is_empty());
}
</code></pre>
<p>標準入力を書く場合、通常のダブルクオートでも改行を含めることはできますが、特別な文字 (<code></code> や <code>&quot;</code> など) を含む場合に備えて、サンプルのように <code>r#&quot;........&quot;#</code> のような形式を使うとよいかもしれません。</p>
<blockquote>
<p>Note: <code>r&quot;...&quot;</code> は基本的には普通の文字列ですが、文字列内の <code></code> をエスケープしません。また <code>&quot;</code> そのものを含めたいときに備えて <code>r####&quot;....&quot;####</code> のように <code>#</code> を任意個挟むことができます。</p>
</blockquote>
<p>なお、この方法では出力を単純に文字列同士の比較によって判定しています。浮動小数点数のように出力に誤差を認める形式や「グラフを一つ出力せよ」のように解が複数あり得る問題のテストにはそのままでは利用できません。それでもテストには任意のコードがかけるわけですから (実際にそこまでするかどうかは別としても) 浮動小数点数やグラフをパースしてチェックするというような使い方も可能です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#プログラムの作成" id="プログラムの作成">プログラムの作成</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>テストが用意できたらプログラムを作成します。エディタを開いて思う通りにコードを書きましょう。</p>
<p>ちなみに、 AtCoder のコンテストでは、一部の例外的なコンテストを除いて、例え類題検索のようなことであっても、コンテスト中に自由にインターネットを検索・閲覧してよいことになっています。</p>
<blockquote>
<p>Note: このことは厳密には各コンテストごとのルール (例えば <a href="https://atcoder.jp/contests/abc160">AtCoder Beginner Contest 160</a> であれば<a href="https://atcoder.jp/contests/abc160/rules">こちら</a>) に記されています。</p>
</blockquote>
<p>したがって、コンテスト中に<a href="https://doc.rust-lang.org/std/index.html">標準ライブラリのドキュメント</a>やその他の外部クレートのドキュメント、使い方やサンプルコードなどを検索することは問題ありません。たとえば <code>itertools</code> にこういうメソッドなかったかなと思うことがあれば、遠慮なく Google で &quot;itertools rust&quot; などと検索してみましょう。大抵はそれでドキュメントが見つかるはずです。</p>
<p>(TODO: コンテスト中に特に有用なページがあればまとめたい)</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#プログラムのテスト" id="プログラムのテスト">プログラムのテスト</a></h1>
<p>一通り書き終わったと思ったら、提出前にまずは一度サンプルケースで答えが合うかどうかを確認してみましょう。コマンド プロンプトまたは端末を開いてプロジェクトフォルダに移動して、次のようなコマンドを実行します。</p>
<pre><code class="language-console">$ cargo test
   Compiling abc000 v0.1.0 (C:\Users\dicen\workspace\daily\2020\0406\abc000)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running target\debug\deps\main-1ecbd097f851d76e.exe

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target\debug\deps\sample_inputs-05a0de7d755e5cc1.exe

running 3 tests
No
test sample3 ... ok
Yes
test sample1 ... ok
No
test sample2 ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>すると、このようにテスト結果が表示されます。このように最後に <code>test result: ok.</code> となっていれば、すべてのテストに成功しているということになります。一方で、もし成功しないテストがあれば、次のようになります。</p>
<pre><code class="language-console">$ cargo test
   Compiling abc000 v0.1.0 (C:\Users\dicen\workspace\daily\2020\0406\abc000)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
     Running target\debug\deps\main-1ecbd097f851d76e.exe

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target\debug\deps\sample_inputs-05a0de7d755e5cc1.exe

running 3 tests
No
test sample2 ... ok
Yes
No
test sample1 ... FAILED
test sample3 ... ok

failures:

---- sample1 stdout ----
thread 'sample1' panicked at 'assertion failed: `(left == right)`
  left: `&quot;Yes\n&quot;`,
 right: `&quot;No\n&quot;`', tests\sample_inputs.rs:16:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    sample1

test result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--test sample_inputs'
</code></pre>
<p>最後の <code>test result: FAILED.</code> により失敗したことが示されています。その横には成功と失敗の個数が示されています。そして上には失敗したときのコマンドの出力も示されています。 <code>assertion failed</code> 以降から、 <code>No</code> と出力すべきところを <code>Yes</code> と出力してしまったことがわかります。</p>
<blockquote>
<p>Note: メッセージに示される <code>left:</code> と <code>right:</code> はマクロ <code>assert_eq!(left, right);</code> に渡される引数の左右です。用意したテストコードでは実際の出力を左、期待される出力を右として <code>assert_eq!(output.stdout_str(), &quot;No\n&quot;);</code> としていたことから、本来は <code>No</code> と出力すべきところを <code>Yes</code> と表示した、ということがわかります。</p>
</blockquote>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#プログラムの提出" id="プログラムの提出">プログラムの提出</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>テストも終わって問題ないとなれば、最後は提出です。書いたコードをコピーして、コンテストページから提出し、結果を確認してください。 <code>AC</code> ならば正解で、 <code>WA</code> ならば不正解です。サンプルが通るのに <code>WA</code> になった場合は、考慮漏れや他のバグがないか確認してみましょう。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#tips小技集" id="tips小技集">Tips（小技集）</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#クレートの使用例" id="クレートの使用例">クレートの使用例</a></h1>
<p>外部クレートの使用例については <a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/2020-Update">2020 Update</a> のページに具体的なソースコードと一緒にまとまっています。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#atcoder運営者向けの情報" id="atcoder運営者向けの情報">AtCoder運営者向けの情報</a></h1>
<p>本章では以下の内容について説明します。</p>
<ul>
<li>Rustツールチェインやクレート（外部ライブラリ）をジャッジサーバへインストールする手順</li>
<li>提出されたプログラムのコンパイルおよび実行手順</li>
</ul>
<h2><a class="header" href="#rustツールチェインやクレートの内容など" id="rustツールチェインやクレートの内容など">Rustツールチェインやクレートの内容など</a></h2>
<ul>
<li>Rust 1.39.0</li>
<li>インストールするクレート：<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/Crates-2019">このページ</a>を参照</li>
</ul>
<h2><a class="header" href="#内容についてのお問い合わせなど" id="内容についてのお問い合わせなど">内容についてのお問い合わせなど</a></h2>
<p>内容について質問などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<p>なお本章のMarkdownソースファイルはGitHub <a href="https://github.com/rust-lang-ja/atcoder-rust-resources">rust-lang-ja/atcoder-rust-resources</a>にあります。</p>
<h2><a class="header" href="#素のrust環境について" id="素のrust環境について">素のRust環境について</a></h2>
<p><a href="https://docs.google.com/spreadsheets/d/1PmsqufkF3wjKN6g1L0STS80yP4a6u-VdGiEv5uOHe0M/edit">AtCoder 2019/7 Language Updateのスプレッドシート</a>では、従来のようにクレートがインストールされていない「素のRust環境」の併設を望む声もあるようです。</p>
<p>そのような環境を望む理由については、正直な話、よくわかりません。
本章の手順に従ってセットアップした環境が問題なく動作するなら、わざわざ別の環境を用意する必要はないからです。
もしユーザプログラム（選手が提出したプログラム）がクレートを使わないなら、本章の手順でインストールしたクレートはないものと同じになります。コンパイルにかかる時間やコンパイルによって生成される実行ファイルには影響を与えません<sup class="footnote-reference"><a href="#crate-makes-no-trouble">1</a></sup>。</p>
<p>あるいは本章でセットアップした環境が何らかの条件下ではうまく動かないものであって、それに当たった際に一切コンパイルできなくなるなどの障害が起こることを心配しているのかもしれません。とはいえジャッジサーバの環境は固定されていますので、そういうことは起こりにくいと考えられます。</p>
<p>もしそれでも欲しいという声があるなら、素のRust環境を別途用意することも技術的には可能です。</p>
<div class="footnote-definition" id="crate-makes-no-trouble"><sup class="footnote-definition-label">1</sup>
<p>このことは他の言語におけるライブラリとまったく同様かと思います。例えばC++にboostがインストールされていても、それらをincludeしたり利用したりしなければコンパイル時間や成果物の性能にほぼ影響を与えないのと同じです。</p>
</div>
<h3><a class="header" href="#方法1環境は1つのままコンパイルコマンドを2種類用意する" id="方法1環境は1つのままコンパイルコマンドを2種類用意する">方法1：環境は1つのまま、コンパイルコマンドを2種類用意する</a></h3>
<p>1つ目の方法は、環境自体は本章の手順で1つだけセットアップして、コンパイルコマンドを切り替えることです。</p>
<p>本章ではクレート入りの環境を利用する方法として、公式のパッケージマネージャCargoを使う方法と、<code>rustc</code>に必要なオプションを追加して呼び出す方法の二通りを提案します。しかし、これはRustコンパイラを呼び出す方法やコンパイルオプションが違うだけであって、ツールチェインを改変するものではありません。<code>rustc</code>を今まで通りに外部クレートのパスを指定せずに呼び出せば、そのまま素の環境ということになります。</p>
<p>たとえばクレート入り環境を利用する方法として「<code>rustc</code>に必要なオプションを付ける方法」を選んだとします。このときのコンパイルコマンドは以下のように直接外部クレートのパスを指定するオプションを付けてコンパイラを実行します<sup class="footnote-reference"><a href="#dep-option-generator">2</a></sup>。</p>
<pre><code class="language-console">$ RUST_LIB=$RUST_HOME/lib
$ rustc --edition=2018 -C opt-level=3 \
    $(rustc-dep-option-generator $RUST_LIB/Cargo.toml $RUST_LIB/target/release/deps) \
    main.rs
</code></pre>
<p>この環境を素の環境、つまりクレートがインストールされていない環境と同じにするには、外部クレート関連のコンパイルオプションをつけずにコンパイラを実行します。</p>
<pre><code class="language-console">$ rustc --edition=2018 -C opt-level=3 main.rs
</code></pre>
<div class="footnote-definition" id="dep-option-generator"><sup class="footnote-definition-label">2</sup>
<p>例示のコマンドラインではクレート検索パス生成ツール（<code>rustc-dep-option-generator</code>コマンド）を利用しています。このコマンドの出力は各外部クレートのパスを指定するコンパイルオプション群です。なおこのツールを利用することは必須ではありませんし、事前にこのツールを使うか手動でコンパイルオプションを生成してベタ書きするのでも構いません。</p>
</div>
<h3><a class="header" href="#方法2文字通り2つの環境を用意する" id="方法2文字通り2つの環境を用意する">方法2：文字通り2つの環境を用意する</a></h3>
<p>2つ目の方法は、本章の環境に加えて、素のRust環境も用意することです。
シェルの環境変数<code>RUSTUP_HOME</code>と<code>CARGO_HOME</code>を本章のものとは違う値に設定して（または<code>unset</code>して）<code>rustup</code>をインストールすれば、本章の環境とは別の場所にRustツールチェインがインストールでされます。</p>
<p>コンパイルの際も環境変数の値を変えることで、本章でセットアップする環境と、素のRust環境を切り替えます。</p>
<table><thead><tr><th align="left">環境変数</th><th align="left">本章でセットアップする環境（クレートを使用できる環境）を使用する場合</th><th align="left">素のRust環境を使用する場合</th></tr></thead><tbody>
<tr><td align="left"><code>RUSTUP_HOME</code></td><td align="left"><code>/usr/local/lib/rust/rustup</code></td><td align="left"><code>rustup</code>をデフォルトの場所にインストールしたのなら<code>unset RUSTUP_HOME</code></td></tr>
<tr><td align="left"><code>CARGO_HOME</code></td><td align="left"><code>/usr/local/lib/rust/cargo</code></td><td align="left">Cargoをデフォルトの場所にインストールしたのなら<code>unset CARGO_HOME</code></td></tr>
</tbody></table>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#本章で想定している環境" id="本章で想定している環境">本章で想定している環境</a></h1>
<h2><a class="header" href="#用語" id="用語">用語</a></h2>
<p>まずは用語を整理します。本章で用いる用語には以下のものがあります。</p>
<ul>
<li><strong>ユーザプログラム</strong>
<ul>
<li>選手が提出したプログラムのこと</li>
</ul>
</li>
<li><strong>ジャッジサーバ</strong>
<ul>
<li>オンラインジャッジを行うサーバのこと。ジャッジサーバはユーザプログラムをコンパイルし、実行する</li>
</ul>
</li>
<li><strong>実行ファイル</strong>（executable file）
<ul>
<li>マシンコードを含み、メモリに読み込んで実行できる形式のファイルのこと。バイナリファイルとも呼ばれる。プログラムのソースコードをコンパイル、リンクすることで生成される</li>
</ul>
</li>
<li><strong>Rustコンパイラ</strong>（<code>rustc</code>）
<ul>
<li><code>rustc</code>コマンドのこと。Rustプログラムのコンパイルとリンクを行う</li>
<li>なお<code>rustc</code>にはリンカの機能は含まれていないため、<code>rustc</code>はリンク時に外部ツールを呼び出すようになっている。ターゲットがLinux Gnu ABIの場合は<code>gcc</code>経由で<code>ld</code>を呼び出す</li>
</ul>
</li>
<li><strong>Cargo</strong>（<code>cargo</code>）
<ul>
<li>Rustのビルドツール兼パッケージマネージャの<code>cargo</code>コマンドのこと</li>
<li>なおカーゴは貨車の意味</li>
</ul>
</li>
<li><strong>Rustツールチェイン</strong>
<ul>
<li>Rustコンパイラ、Cargo、Rustの標準ライブラリなどをバージョンごとにまとめたもの</li>
</ul>
</li>
<li><strong>Rustup</strong>（<code>rustup</code>）
<ul>
<li>Rustツールチェインの管理ツールである<code>rustup</code>コマンドのこと</li>
<li>指定したバージョンのRustツールチェインを簡単にインストールできるだけでなく、複数バージョンのツールチェインも管理できる</li>
<li><code>rustc</code>やCargoと同様、Rustプロジェクトチームにより公式にサポートされている</li>
</ul>
</li>
<li><strong>クレート（crate）</strong>
<ul>
<li>クレートは貨物などを入れる木箱の意味</li>
<li>Rustにはlib crateとbin crateがある</li>
<li>ライブラリクレート（lib crate）はRustで書かれたライブラリのこと。コンパイルするとrlibファイルが作られる</li>
<li>バイナリクレート（bin crate）はRustで書かれたアプリケーションのこと。コンパイル、リンクすると実行ファイルが作られる</li>
<li>世界中のRustユーザが作成した無数のクレートが、セントラルリポジトリの<a href="https://crates.io">crates.io</a>で公開されている</li>
<li>一般にクレートと呼ぶ場合は文脈によりバイナリクレートかライブラリクレートかを区別する</li>
<li>今回の例では、外部クレートは全てlib crateで、外部クレートをまとめてコンパイルするため・ユーザープログラムをコンパイルするために使うクレートはbin crate</li>
</ul>
</li>
<li><strong>Cargoパッケージ</strong>
<ul>
<li>Cargoの1単位。Rustのソースコードや<code>Cargo.toml</code>などの設定ファイルで構成される</li>
<li>1つのCargoパッケージには単一または複数のクレートが含まれる</li>
</ul>
</li>
<li><strong>Cargoプロジェクト</strong>
<ul>
<li>基本的にCargoパッケージと同じもの</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#想定する環境" id="想定する環境">想定する環境</a></h2>
<p>本章ではAtCoderのジャッジサーバ環境として、以下のものを想定しています。</p>
<ul>
<li>Ubuntu 18.04 LTS x86_64</li>
<li>ユーザプログラムは何らかのコンテナ内で実行される
<ul>
<li>インターネットなどのネットワークアクセスは不可</li>
<li>物理メモリ、ディスクファイルサイズ、プロセス数などの制限がある</li>
<li>ユーザプログラムが出力したファイルは、テストケースを1つ実行するごとに削除される</li>
</ul>
</li>
<li>プログラミング言語ごとにファイルシステムが分かれているわけではない
<ul>
<li>たとえば提出言語としてBashやPythonを選択したときに、他の言語のコンパイラを実行するようなスクリプトを提出、実行できる</li>
<li>（このようなプログラムを提出することは推奨はされないだろうが、現状は可能となっている）</li>
</ul>
</li>
<li>ユーザプログラムをコンパイル、実行するLinuxユーザは、単一のユーザなのか、複数のユーザなのかは不明</li>
</ul>
<h2><a class="header" href="#一般的なrustプログラム開発環境との違い" id="一般的なrustプログラム開発環境との違い">一般的なRustプログラム開発環境との違い</a></h2>
<p>一般的なRustプログラムの開発では<code>rustup</code>をデフォルト設定で使うことで、いまログインしているLinuxユーザ専用の場所にツールチェインをインストールします。またユーザプログラムのビルドにはCargoを使い、そのプログラムが依存しているクレートのソースファイルを自動的にダウンロードし、ユーザプログラムと共にコンパイルします。</p>
<p>ジャッジサーバではこの方法はあまりうまくいきません。</p>
<ul>
<li>Linuxユーザを複数使用している場合に、ユーザごとにツールチェインをインストールすることになる。</li>
<li>ツールチェインのファイルパーミッションがそのままだと、悪意のあるユーザプログラムがツールチェインを改変してしまうかもしれない。</li>
<li>クレートのソースファイルのダウンロードをCargoに任せると
<ul>
<li>ダウンロードに時間と回線負荷がかかる。</li>
<li>crates.ioの障害の際や依存クレートのいずれかが取り消された際などにダウンロードできずエラーとなる可能性がある。</li>
<li>不正防止のためにユーザプログラムの実行時にネットワークを制限する場合、ビルドと実行の間でネットワークから切断する処理を挿入する必要がある。</li>
</ul>
</li>
<li>ジャッジの際に毎回クレートがコンパイルされることになり非効率。
<ul>
<li>マシンスペックにもよりますが、手元の環境 (i5-8250U) では <strong>CPU全コア100%で並列実行して分単位の時間</strong> がかかります。</li>
</ul>
</li>
</ul>
<p>そこで本章では以下のようにします。</p>
<ul>
<li>Rustツールチェインを、ジャッジサーバ上の全Linuxユーザがread-onlyでアクセスできる場所にインストールする。</li>
<li>選手が使用できるクレートを事前に選定し、それらを全て設定したプロジェクトをコンパイルしておく。
<ul>
<li>コンパイルしたプロジェクトはジャッジサーバ上の全Linuxユーザがread-onlyでアクセスできる場所に保存する。</li>
</ul>
</li>
<li>ユーザプログラムをコンパイルする際は以下のいずれかの方法をとる。
<ul>
<li>事前にコンパイルしたCargoプロジェクトをコピーした上で<code>main.rs</code>をユーザプログラムに置き換えてCargoを用いる。</li>
<li>所定のオプションを簡単なツールにより生成して<code>rustc</code>を直接実行する。</li>
</ul>
</li>
</ul>
<p>最後のユーザプログラムのコンパイルについて二つの方法<sup class="footnote-reference"><a href="#good-is-bad-each-other">1</a></sup>がありますが、それぞれについて補足します。</p>
<div class="footnote-definition" id="good-is-bad-each-other"><sup class="footnote-definition-label">1</sup>
<p>これらはお互いに「他方の短所を解決するかわりに他方の長所を持たない」という関係があります。</p>
</div>
<h3><a class="header" href="#cargoを用いる場合" id="cargoを用いる場合">Cargoを用いる場合</a></h3>
<p>通常のRustプロジェクトと同様ですが、通常なら意識する必要のない「インターネットからの依存クレートの自動ダウンロード」と「依存クレートの自動再コンパイル」を避ける必要があります。自動ダウンロードを避けるには<code>--offline</code>オプションをつける必要があります<sup class="footnote-reference"><a href="#offline-option">2</a></sup>。依存クレートの自動再コンパイルを正式に抑制する方法はありません。ただし、ツールチェインもクレートもバージョンアップしない固定された環境ではまず起きないだろうとは思われます<sup class="footnote-reference"><a href="#prevent-auto-recompile">3</a></sup>。</p>
<div class="footnote-definition" id="offline-option"><sup class="footnote-definition-label">2</sup>
<p>これはRust 1.36から導入された、ネット接続環境のない場合でもローカルキャッシュを活用してできるだけコンパイル不能になることを避けるオプションです。詳しくは<a href="atcoder-env/ncameron.org/blog/cargo-offline/">こちら</a>もご参照ください。</p>
</div>
<div class="footnote-definition" id="prevent-auto-recompile"><sup class="footnote-definition-label">3</sup>
<p>これはCargoのソースを見たわけ <strong>ではなく</strong> 、多少試したところは大丈夫そうだという推測でしかありませんし、仮に今は大丈夫でも将来的に変更が加わる可能性もあります。</p>
</div>
<p>考えられる長所と短所を述べますが、要約すると、長所は公式であることです。逆に短所はディレクトリ構成が縛られること、想定されていない環境下でも確実に動作するのか分からないことです。</p>
<h4><a class="header" href="#長所" id="長所">長所</a></h4>
<ul>
<li>公式のツールなので他の準備が不要。</li>
<li>公式のツールなのでバグにも見舞われにくく、処理の信頼性が高い。</li>
</ul>
<h4><a class="header" href="#短所" id="短所">短所</a></h4>
<ul>
<li>全部入りのCargoプロジェクト全体をコピーして実行環境に展開する必要がある。
<ol>
<li>所定のディレクトリ構成にしなければならないためです。
<ul>
<li><code>Cargo.toml</code>があり、<code>src</code>ディレクトリがあり、...。</li>
</ul>
</li>
<li><code>target</code>ディレクトリ以下に生成されている依存クレートのコンパイルキャッシュを利用するためです。
<ul>
<li>Cargoを動作させる <strong>だけ</strong> であれば<code>Cargo.toml</code>をコピーして<code>src</code>に<code>main.rs</code>を入れるだけOKです。問題なくコンパイル・実行できます。ただしそれでは依存クレートを含めてゼロからコンパイルしますので、マシンパワーにもよりますが通常 <strong>並列処理の高負荷と分単位の時間</strong> がかかります。従って既に一度ビルドされたプロジェクトを丸ごとコピーしてくる必要があります。</li>
<li>(参考) この<code>target</code>ディレクトリのサイズは手元環境では163MBでした。コンパイルの度にこれだけのディレクトリをコピーする必要があります。</li>
</ul>
</li>
<li>実行環境の改竄から守るためです。
<ul>
<li>もしCargoプロジェクトを使い回すことにすると、例えば次のようなことが可能になります。
<ul>
<li>一回目の実行で、ライブラリを差し替える、または、必要なファイルに偽装して計算結果を保存し、二回目の実行で不正な動作をさせる。</li>
<li><code>.cargo/config</code>ファイルに設定を追加する(例:コンパイルオプションを変更するなど)。</li>
</ul>
</li>
<li>プロジェクトに属するファイル・ディレクトリを読取専用にすれば緩和されると思いますが、この場合<code>cargo</code>自体が処理の途中に何らかの形で書き込みを行う(ログやキャッシュなど)ことがあれば正常に動作しない可能性がゼロではありません。</li>
</ul>
</li>
</ol>
</li>
<li>依然としていつ依存クレートの再コンパイルが行なわれるかについて保証を得られない。
<ul>
<li>再コンパイルが起こると通常 <strong>並列処理の高負荷と分単位の時間</strong> がかかります。</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#rustcを直接実行する場合" id="rustcを直接実行する場合">rustcを直接実行する場合</a></h3>
<p>Cargoは高機能ですが、実際のコンパイル処理は適切なオプションをつけて<code>rustc</code>を呼び出しているにすぎません。Cargoと同じコンパイルオプションを生成することができればCargoに頼らなくても実行ファイルを生成できます。要するに、現在のRustと同様に単体ファイルを<code>rustc</code>でコンパイルする形ですが、外部クレートのパスなどを指定するコンパイルオプションを追加するということです<sup class="footnote-reference"><a href="#adding-library-path-options">4</a></sup>。</p>
<div class="footnote-definition" id="adding-library-path-options"><sup class="footnote-definition-label">4</sup>
<p>イメージとしては<code>gcc</code>等でいう<code>-lsome_library</code>のようなものになります。</p>
</div>
<p>考えられる長所と短所を述べますが、要約すると、長所はCargoを用いる場合の短所が解決されていることです。逆に短所は公式ではないことで、Cargoを使っていれば起きないような齟齬が起きる可能性があることです。</p>
<h4><a class="header" href="#長所-1" id="長所-1">長所</a></h4>
<ul>
<li>具体的に<code>rustc</code>を呼び出すため、実際に為される処理が明確にコンパイルとリンクのみであり、Cargoのようにブラックボックスではない。
<ul>
<li>依存クレートの自動ダウンロードも自動再コンパイルも<code>rustc</code>の機能ではないので大丈夫です。</li>
</ul>
</li>
<li>ディレクトリ構成を気にする必要はない。
<ul>
<li>今まで通り、適当なディレクトリにユーザプログラムを好きな名前で配置するだけでOKです。</li>
</ul>
</li>
<li>全部入りのCargoプロジェクトをコピーする必要はない。
<ul>
<li>read-onlyのシステム領域に依存関係のコンパイル済みクレートを用意しておけば、参照する依存クレートのパスとしてその場所を指定するだけで事足ります。</li>
</ul>
</li>
<li>依存クレートを読み取り専用にすることができる。
<ul>
<li>Cargoの場合は再コンパイルにより依存クレートのファイルを更新する可能性があるためread-onlyとしたときにどう動作するか確信できませんが、<code>rustc</code>を直接実行する場合は依存クレートのファイルを参照するだけですので、read-onlyでも問題ないと思われます。</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#短所-1" id="短所-1">短所</a></h4>
<ul>
<li>
<p>コンパイルオプションを準備する必要がある。</p>
<ul>
<li>手でやる場合は<code>cargo build --release -v</code>の出力を参考にして必要なオプションを選ぶ必要があります。</li>
<li>コンパイルオプションを生成するためのツールを作成しましたので、それを利用することもできます。このツールを利用する場合はそのツールのコンパイルと実行が必要です<sup class="footnote-reference"><a href="#tool-compilation">5</a></sup>。</li>
</ul>
</li>
<li>
<p>オプションが正しいかどうか、欠けていないかどうかを気にする必要がある。</p>
<ul>
<li>普通は<code>cargo build</code>で全て終わるため<code>rustc</code>を直接実行することはなく、どのクレートにも手動でリンクする場合のオプションに関する情報はありません。</li>
<li>ただし一度テストして問題がなかったのなら、固定されている環境で後々問題を起こすことは考えづらいです。</li>
</ul>
</li>
<div class="footnote-definition" id="tool-compilation"><sup class="footnote-definition-label">5</sup>
<p>とはいえツールはRustで書かれているため<code>git clone</code>と<code>cargo build</code>程度です。</p>
</div>
</ul>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#インストール" id="インストール">インストール</a></h1>
<p>本節では以下の内容について説明します。</p>
<ul>
<li>Rustツールチェインのインストール</li>
<li>クレートのコンパイルとインストール</li>
<li>(必要なら) クレートの検索パス生成ツールのインストール</li>
</ul>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#rustツールチェインのインストール" id="rustツールチェインのインストール">Rustツールチェインのインストール</a></h1>
<p>このページではAtCoderのジャッジサーバにRustツールチェインをインストールする手順を説明します。</p>
<h2><a class="header" href="#rustバージョン" id="rustバージョン">Rustバージョン</a></h2>
<p>今回の言語アップデートでは2019年11月7日にリリースされた1.39.0をインストールします。</p>
<p>Rustの安定版（stable版）は6週間ごとにリリースされますので、既にバージョン1.40.0が12月19日にリリースされています。ただ、安定性のためには世に出てからある程度の時間が経っているバージョンを選ぶ方が望ましいと考えられますので、ここでは1つ前のバージョンをインストールします。様子を見る期間については、現在のところはおよそ次期バージョンがリリースされるまでを1つの目安としています。</p>
<p>ツールチェインのインストールには<code>rustup</code>というRustプロジェクト公式のコマンドラインツールを使います。
これにより特定のバージョンのRustをインストールすることが可能になります。</p>
<h2><a class="header" href="#ツールチェインの内容とインストール先" id="ツールチェインの内容とインストール先">ツールチェインの内容とインストール先</a></h2>
<p>今回インストールするRustツールチェインには以下のものが含まれています。</p>
<ul>
<li>Rustコンパイラである<code>rustc</code>コマンド</li>
<li>Rustのビルドツール兼パッケージマネージャである<code>cargo</code>コマンド</li>
<li>Rustの標準ライブラリとAPIドキュメント</li>
</ul>
<p>実際のコンパイルにもCargoを利用する場合はもちろんですが、運用時には<code>rustc</code>に必要なオプションを付けてコンパイルする方法をとる場合でも、依存ライブラリをまとめてコンパイルするためにCargoを利用します。具体的にはこのページに続く数ページをご覧ください。</p>
<p>Rustツールチェインはデフォルトでは<code>rustup</code>を実行したLinuxユーザのホームディレクトリ配下（<code>~/.rustup/toolchains</code>）にインストールされます。
しかし今回はジャッジサーバ上の全てのLinuxユーザから使えるよう、<code>/usr/local/lib/rust</code>配下にインストールします。
このディレクトリは一般のLinuxユーザからは書き込みができないように設定し、ジャッジの際にツールチェインがユーザプログラムによって変更されないよう保護します。</p>
<h2><a class="header" href="#依存ソフトウェアのインストール" id="依存ソフトウェアのインストール">依存ソフトウェアのインストール</a></h2>
<p>Rustツールチェインをインストールする前に、Rustプログラムのリンクやクレートのビルドに必要なソフトウェアをインストールしましょう。
必要なソフトウェアは以下のとおりです。</p>
<ul>
<li>Rustツールチェインやクレートのダウンロードに必要なツール：curl, git-core</li>
<li>ユーザプログラムのリンク時に必要なツール：gcc, binutils</li>
<li>一部のRustクレートのビルドに必要なツール：make, pkg-config</li>
</ul>
<p>以下のコマンドを実行します。</p>
<pre><code class="language-console">$ sudo apt update
$ sudo apt install -y curl git-core gcc binutils make pkg-config
</code></pre>
<h2><a class="header" href="#rustツールチェインのインストール-1" id="rustツールチェインのインストール-1">Rustツールチェインのインストール</a></h2>
<p><code>rustup</code>とRustツールチェインをインストールしましょう。
以下のコマンドを実行します。</p>
<pre><code class="language-console">$ sudo -i

# whoami
root

# RUST_TOOLCHAIN=1.39.0
# export RUST_HOME=/usr/local/lib/rust
# export RUSTUP_HOME=${RUST_HOME}/rustup
# export CARGO_HOME=${RUST_HOME}/cargo

# mkdir -p $RUST_HOME
# chmod 0755 $RUST_HOME

## rustupをインストールし、同時に指定したバージョンのRustツールチェインをインストールする
# curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | \
    sh -s -- -y --default-toolchain &quot;${RUST_TOOLCHAIN}&quot; --no-modify-path
</code></pre>
<p>インストールに成功すると以下のように表示されます。</p>
<pre><code class="language-console">info: downloading installer
info: syncing channel updates for '1.39.0-x86_64-unknown-linux-gnu'
info: latest update on 2019-11-07, rust version 1.39.0 (4560ea788 2019-11-04)
info: downloading component 'rustc'
info: downloading component 'rust-std'
info: downloading component 'cargo'
...（中略）...

  1.39.0 installed - rustc 1.39.0 (4560ea788 2019-11-04)


Rust is installed now. Great!

To get started you need Cargo's bin directory (/usr/local/lib/rust/cargo/bin)
in your PATH environment variable.

To configure your current shell run source /usr/local/lib/rust/cargo/env
</code></pre>
<h2><a class="header" href="#環境変数の設定" id="環境変数の設定">環境変数の設定</a></h2>
<p>rootユーザと一般のLinuxユーザがRustツールチェインを使えるように設定しましょう。
それぞれのユーザのシェルの初期設定ファイルに以下のコマンドを追加します。
（<code>bash</code>の例です）</p>
<pre><code class="language-bash"># .bashrcファイルに以下のコマンドを追加する
export RUST_HOME=/usr/local/lib/rust
export RUSTUP_HOME=${RUST_HOME}/rustup
export CARGO_HOME=${RUST_HOME}/cargo
source ${CARGO_HOME}/env
</code></pre>
<p>最後の<code>source</code>コマンドは、コマンド検索パス（<code>PATH</code>）に<code>/usr/local/lib/rust/cargo/bin</code>を追加します。</p>
<h2><a class="header" href="#インストール後の動作確認" id="インストール後の動作確認">インストール後の動作確認</a></h2>
<p>Rustツールチェインが正しくインストールできたか確認しましょう。
一般のLinuxユーザで以下のコマンドを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行

$ source ~/.bashrc

$ echo $RUSTUP_HOME
/usr/local/lib/rust/rustup

$ which rustc
/usr/local/lib/rust/cargo/bin/rustc

## バージョンなどを確認
$ rustc -V
rustc 1.39.0 (4560ea788 2019-11-04)

$ cargo -V
cargo 1.39.0 (1c6ec66d5 2019-09-30)

$ rustup -V
rustup 1.21.1 (7832b2ebe 2019-12-20)

$ rustup show
Default host: x86_64-unknown-linux-gnu

1.39.0-x86_64-unknown-linux-gnu (default)
rustc 1.39.0 (4560ea788 2019-11-04)

## Rustプログラムのビルドと実行ができることを確認
$ cd /tmp
$ cargo new hello &amp;&amp; cd $_
$ cargo run
Hello, world!   # このように表示されればOK

$ cd
$ rm -rf /tmp/hello
</code></pre>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#クレートのコンパイルとインストール" id="クレートのコンパイルとインストール">クレートのコンパイルとインストール</a></h1>
<p>このページではAtCoderのジャッジサーバにRustの外部ライブラリであるクレートをインストールする手順を説明します。</p>
<h2><a class="header" href="#インストールするクレートについて" id="インストールするクレートについて">インストールするクレートについて</a></h2>
<p>今回インストールするクレートは、SlackのRust日本語コミュニティ「rust-jp」のメンバーがAtCoderでぜひ使いたいと考えているものです。
大半は既存のクレートですが、この機会に新たに開発したものもあります。</p>
<p>これらのクレートは主に以下の種類に分類されます。</p>
<ul>
<li>Rust の標準ライブラリにないが、他のいくつかの言語では標準の機能であって、かつ競プロ以外でも広く使われているもの
<ul>
<li>例：C++の<code>lower_bound</code>や<code>bitset</code>に相当する機能</li>
</ul>
</li>
<li>競技プログラミング特化型だが、競プロの面白さを損なわない範囲（ズルにならない範囲）で便利になるもの
<ul>
<li>例：Rustでは入力関連の記述が煩雑になりがちなので、それらを簡潔に記述できるマクロ集</li>
</ul>
</li>
<li>セキュリティなどの理由から高速性が犠牲になっている機能を置き換え、特にマラソンにおいて威力を発揮するもの
<ul>
<li>例：標準ライブラリのハッシュ関数はDoS攻撃を避けるために暗号強度があり、計算量が多い。
競技プログラミングでは暗号強度は求められず、より計算量の少ないハッシュ関数で十分</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#atcoder運営者様へのお願い" id="atcoder運営者様へのお願い">AtCoder運営者様へのお願い</a></h3>
<p>対象クレートの一覧は<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/Crates-2019">このページ</a>にあります。
ジャッジサーバで使用して問題ない内容か、インストール前にレビューをお願いいたします。</p>
<p>質問や要望などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<h2><a class="header" href="#ファイルレイアウトとクレートの事前コンパイル" id="ファイルレイアウトとクレートの事前コンパイル">ファイルレイアウトとクレートの事前コンパイル</a></h2>
<p>インストール作業に入る前に、背景を説明します。
一般的なCargoを使用した開発では、<code>Cargo.toml</code>という設定ファイルに依存クレートの情報を記述します。
<code>cargo build</code>コマンドを実行すると、Cargoはそれらのクレートのソースコードをダウンロードし、適切なオプションと共に<code>rustc</code>を実行することでクレートをコンパイルします。
クレートのソースコードは<code>$CARGO_HOME/registory/src</code>にダウンロードされ、コンパイル済みのクレート（<code>rlib</code>ファイル）は<code>Cargo.toml</code>が置かれたディレクトリを起点とする相対ディレクトリ<code>./target/release/deps</code>配下に出力されます。</p>
<h3><a class="header" href="#一般的な開発時のファイルレイアウト" id="一般的な開発時のファイルレイアウト">一般的な開発時のファイルレイアウト</a></h3>
<pre><code class="language-console">$HOME   # ユーザのホームディレクトリ
|-- $CARGO_HOME (~/.cargo)
|   └-- registory
|       └-- src
|           └-- クレートのソースコード
|
└-- my-package
    |-- Cargo.toml    # 設定ファイル。依存クレートの情報が書かれている
    |-- src
    |   └-- main.rs   # Rustプログラムのソースコード
    └-- target
        └-- release
            |-- deps
            |   |-- X.rlib  # コンパイル済みのクレート
            |   └-- Y.rlib
            └-- main        # コンパイル、リンク済みの実行ファイル
</code></pre>
<p>ジャッジサーバーでは様々な条件が通常の環境と異なるため、<a href="atcoder-env/./supported-environment.html#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AArust%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84">最初に説明した通り</a>いくつか工夫をする必要があります。</p>
<p>まず、今回は各ファイルを以下のように配置し、クレートのコンパイルは導入時に済ませておくことにします。</p>
<h3><a class="header" href="#atcoderジャッジサーバでのファイルレイアウト導入時に配置するもの" id="atcoderジャッジサーバでのファイルレイアウト導入時に配置するもの">AtCoderジャッジサーバでのファイルレイアウト（導入時に配置するもの）</a></h3>
<pre><code class="language-console">$RUST_HOME (/usr/local/lib/rust)
|-- $CARGO_HOME (/usr/local/lib/rust/cargo)
|   └-- registory
|       └-- src
|           └-- クレートのソースコード
└-- lib
    |-- Cargo.toml          # 設定ファイル。依存クレートの情報が書かれている
    └-- target
        └-- release
            └-- deps
                |-- X.rlib  # コンパイル済みのクレート
                └-- Y.rlib
</code></pre>
<p>そしてジャッジの際には<a href="atcoder-env/./supported-environment.html#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AArust%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84">以前説明した</a>Cargoを利用する方法と<code>rustc</code>を利用する方法のいずれかを利用してコンパイルします。</p>
<h3><a class="header" href="#cargo-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの" id="cargo-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの">[cargo] AtCoderジャッジサーバでのファイルレイアウト（ジャッジの際に作成するもの）</a></h3>
<pre><code class="language-console">$HOME                      # ユーザのホームディレクトリ
└-- WORKAREA               # ジャッジ用の一時ディレクトリ
    └-- lib                # 全部入りプロジェクトをまるまるコピーしたもの
        |-- main.rs        # ユーザプログラム（提出されたプログラム）のソースコードに置き換える
        |-- Cargo.toml
        └-- target
            └-- release
                |-- deps   # (外部クレートのコンパイルキャッシュ)
                └-- atcoder-rust-base # コンパイル、リンク済みの実行ファイル
</code></pre>
<h3><a class="header" href="#rustc-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの" id="rustc-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの">[rustc] AtCoderジャッジサーバでのファイルレイアウト（ジャッジの際に作成するもの）</a></h3>
<p>Cargoを使用せず、<code>rustc</code>に適切なオプション（ライブラリ検索パスなど）を与えて実行することで、事前にコンパイルしておいた<code>rlib</code>ファイルとリンクさせます。</p>
<pre><code class="language-console">$HOME             # ユーザのホームディレクトリ
└-- WORKAREA      # ジャッジ用の一時ディレクトリ
    |-- main.rs   # ユーザプログラム（提出されたプログラム）のソースコード
    └-- main      # コンパイル、リンク済みの実行ファイル
</code></pre>
<h2><a class="header" href="#クレートのコンパイルに使用するcargoパッケージのダウンロード" id="クレートのコンパイルに使用するcargoパッケージのダウンロード">クレートのコンパイルに使用するCargoパッケージのダウンロード</a></h2>
<p>それではインストール作業に入りましょう。実際のコンパイルにCargoを使う場合も<code>rustc</code>を使う場合もここは同様です。
クレートの事前コンパイルに使用するCargoパッケージは、GitHub <a href="https://github.com/rust-lang-ja/atcoder-rust-base/tree/ja-all-enabled">rust-lang-ja/atcoder-rust-base（ja-all-enabledブランチ）</a>に用意されています。
このパッケージには<code>Cargo.toml</code>ファイルなどが含まれており、インストール対象のクレートがすでに設定されています。
（<code>[dependencies]</code>セクションに書かれています）</p>
<p>このリポジトリを<code>git clone</code>し、<code>/usr/local/lib/rust/lib</code>に配置します。以下のコマンドを実行します。</p>
<pre><code class="language-console">## rootユーザで作業する
$ sudo -i
# whoami
root

# echo $RUST_HOME
/usr/local/lib/rust

## Cargoパッケージをgit cloneする
# git clone https://github.com/rust-lang-ja/atcoder-rust-base.git \
    --branch ja-all-enabled --single-branch \
    ${RUST_HOME}/lib
</code></pre>
<h2><a class="header" href="#クレートを削除する" id="クレートを削除する">クレートを削除する</a></h2>
<p>検討の結果、一部のクレートは残念ながら導入すべきでないクレートだと判断されることもあるかと思います。そういった場合は<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>を通してご連絡頂ければ当該クレートとそれに関連するテストの削除等の対応をさせていただきますが、一応、その方法も説明しておこうと思います。</p>
<p>例えば、競プロ入出力補助の<code>proconio</code>が相応しくないので削除したいとなったとします。まずはこのクレートを依存から削除する必要があります。<code>git clone</code>したディレクトリ内の<code>Cargo.toml</code>ファイルを開き、<code>[dependencies]</code>セクションを見つけてください。すると例えば次のようにクレートが並んでいるかと思います。</p>
<pre><code class="language-toml">[dependencies]
# AtCoder 2019年言語アップデート以降に使用できるクレート

# 競技プログラミングの入出力サポート
proconio = { version = &quot;=0.3.4&quot;, features = [&quot;derive&quot;] }

# f64のOrd/Eq実装
ordered-float = &quot;=1.0.2&quot;

(...以下略...)
</code></pre>
<p>クレートによってオプションが付せられていることもありますが、<code>{削除したいクレート名} = ...</code>となっている行をコメントアウトまたは削除してください。</p>
<p>続いてテストを削除します。<code>src/main.rs</code>ファイルを開くと、ずらっとテスト関数が並んでいます。これらの関数から<code>run_{削除したいクレート名}</code>と<code>test_{削除したいクレート名}</code>という関数を丸ごと削除してください。<code>test_{削除したいクレート名}</code>関数は、その前の行に<code>#[test]</code>アトリビュートがついているかと思いますので、それごと削除してください。</p>
<p>そして<code>main()</code>関数内にある<code>run_{削除したいクレート名}</code>関数を呼び出す文を削除してください。</p>
<p>基本的にはこれで削除は完了です。この後クレートのテストを行いますが、ここで<code>unresolved import</code>系のエラーが出るようなら適宜削除してください。</p>
<p>削除するべきコードが無い場合、テストが別のファイルに分かれている場合があります。例えば<code>jemallocator</code>系を削除したいならば<code>tests/test_jemallocator.rs</code>というファイルを削除してください。</p>
<p>また<code>jemallocator</code>系を削除する場合、<code>Cargo.toml</code>内の以下の部分も削除してください。</p>
<pre><code class="language-toml">[features]
jemalloc = [&quot;jemalloc-ctl&quot;, &quot;jemallocator&quot;]
default = [&quot;jemalloc&quot;]
</code></pre>
<pre><code class="language-toml"># 代替ヒープアロケータ。条件によってはシステムアロケータより速いことも
[target.'cfg(not(windows))'.dependencies]
jemallocator = { version = &quot;=0.3.2&quot;, optional = true }
jemalloc-ctl = { version = &quot;=0.3.3&quot;, optional = true }
</code></pre>
<pre><code class="language-toml">[[test]]
name = &quot;jemallocator&quot;
path = &quot;tests/test_jemallocator.rs&quot;
required-features = [&quot;jemalloc&quot;]
</code></pre>
<h2><a class="header" href="#クレートのテスト" id="クレートのテスト">クレートのテスト</a></h2>
<p>一度、導入したクレートが正しく動作するのかを確認しましょう。</p>
<p>テストコードは<code>$RUST_HOME/lib/src/</code>及び<code>$RUST_HOME/lib/tests</code>にあります。先に述べたように使わないクレートに関わるコードは削除してください。実行するには、<code>cargo test</code>コマンドを入力します。</p>
<pre><code class="language-console"># cd $RUST_HOME/lib
$ cargo test --release
   Compiling atcoder-rust-base v0.1.0 (...)
    Finished release [optimized] target(s) in 7.31s
     Running target\release\deps\...

running 11 tests
test test_ascii ... okYes
Yes

test test_bitset_fixed ... ok
test test_modtype ... ok
test test_ordered_float ... ok
test test_permutohedron ... ok
test test_itertools ... ok
test test_rand_family ... ok
test test_proconio ... ok
test test_regex ... ok
test test_rustc_hash ... ok
test test_superslice ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>多少表示されるテストの個数は異なるかもしれませんが、一番下の行が<code>test result: ok.</code>で<code>0 failed;</code>となっていれば問題ありません。</p>
<p>また今回、使用するクレート自体のテストを実行するためのツール、<code>dep-tests</code>を作成しました。
<code>dep-tests</code>はcargo commandのエイリアスとして、<code>cargo dep-tests</code>で起動できます。
ただし<code>alias</code>は任意のスクリプトを実行できないのでcwdが<code>$RUST_HOME/lib</code>である必要があります。
以下、cwdを<code>$RUST_HOME/lib</code>とします。</p>
<p>参考: <a href="https://qiita.com/ubnt_intrepid/items/9600fd734e6d116bc9cb">cargo で npm-scripts 的なことをする</a></p>
<pre><code class="language-toml">[alias]
dep-tests = [&quot;run&quot;, &quot;--manifest-path&quot;, &quot;./dep-tests/Cargo.toml&quot;, &quot;--&quot;]
</code></pre>
<pre><code class="language-console">$ cargo dep-tests --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `dep-tests/target/debug/dep-tests --help`
dep-tests 0.0.0
Run all of the tests in the dependency graph.

USAGE:
    dep-tests [FLAGS] [OPTIONS] &lt;dir&gt;

FLAGS:
        --all-features           Activate all available features
        --no-default-features    Do not activate the `default` feature
        --frozen                 Require Cargo.lock and cache are up to date
        --locked                 Require Cargo.lock is up to date
        --offline                Run without accessing the network
    -h, --help                   Prints help information
    -V, --version                Prints version information

OPTIONS:
    -p, --package &lt;SPEC&gt;...         Package to run test for
        --features &lt;FEATURES&gt;...    Space-separated list of features to activate
        --color &lt;WHEN&gt;              Coloring: auto, always, never
    -d, --depth &lt;N&gt;                 How deep in the dependency chain to search

ARGS:
    &lt;dir&gt;    Directory to run tests [default: /tmp/atcoder-rust-base-dep-tests]
</code></pre>
<pre><code class="language-console">$ cargo dep-tests --all-features -d 1
</code></pre>
<p>いくつかのクレートは<code>dep-tests</code>で動かないのでテストしないように除外されています。
そのリストと理由は<code>$RUST_HOME/lib/dep-tests.toml</code>に記述されています。</p>
<p><code>dep-tests</code>の動作の説明をしておきます。</p>
<p>実は<code>cargo</code>にはdependency graph上にあるクレートのテストをそのまま実行する機能があります。</p>
<pre><code class="language-console">$ cargo test -p maplit -p num
</code></pre>
<p>しかしこれには致命的な欠点があり、<a href="https://github.com/rust-lang/cargo/blob/0.40.0/src/cargo/ops/cargo_compile.rs#L346-L355"><code>[dev-dependencies]</code>が一つでもあると問答無用で</a>拒否されます。</p>
<pre><code class="language-console">$ cargo test -p regex
error: package `regex` cannot be tested because it requires dev-dependencies and is not a member of the workspace
</code></pre>
<p>このエラーは<a href="https://github.com/rust-lang/cargo/pull/6192"><code>rust-lang/cargo#6192</code></a>で追加されました。
禁止されている理由はこのPRで言及されている通り、dev-dependencyがある場合ワースクペース上には無い新たなクレートが必要になることがあるためです。
<code>dep-tests</code>は『拡張』したワークスペースを新たに作成してその上でテストを実行します。</p>
<p>例えば<code>itertools v0.8.1</code>, <code>regex v1.3.1</code>を対象にした場合、以下のような<code>Cargo.toml</code>が生成されます。</p>
<pre><code class="language-toml">[package]
name = &quot;atcoder-rust-base-dep-tests&quot;
version = &quot;0.0.0&quot;
edition = &quot;2018&quot;
publish = false

[workspace]
members = [&quot;./itertools-0.8.1&quot;, &quot;./regex-1.3.1&quot;]

[patch.crates-io]
itertools = {path = &quot;./itertools-0.8.1&quot;}
regex = {path = &quot;./regex-1.3.1&quot;}

[dependencies]
_0 = {package = &quot;aho-corasick&quot;,version = &quot;=0.7.6&quot;,default-features = false,features = [&quot;default&quot;, &quot;std&quot;]}
_1 = {package = &quot;alga&quot;,version = &quot;=0.9.2&quot;,default-features = false,features = [&quot;default&quot;, &quot;std&quot;]}
# 略
_25 = {package = &quot;itertools&quot;,path = &quot;./itertools-0.8.1&quot;,default-features = false,features = [&quot;default&quot;, &quot;use_std&quot;]}
# 略
_84 = {package = &quot;regex&quot;,path = &quot;./regex-1.3.1&quot;,default-features = false,features = [&quot;aho-corasick&quot;, &quot;default&quot;, &quot;memchr&quot;, &quot;perf&quot;, &quot;perf-cache&quot;, &quot;perf-dfa&quot;, &quot;perf-inline&quot;, &quot;perf-literal&quot;, &quot;std&quot;, &quot;thread_local&quot;, &quot;unicode&quot;, &quot;unicode-age&quot;, &quot;unicode-bool&quot;, &quot;unicode-case&quot;, &quot;unicode-gencat&quot;, &quot;unicode-perl&quot;, &quot;unicode-script&quot;, &quot;unicode-segment&quot;]}
# 略
_107 = {package = &quot;version_check&quot;,version = &quot;=0.9.1&quot;,default-features = false,features = []}
_108 = {package = &quot;whiteread&quot;,version = &quot;=0.4.4&quot;,default-features = false,features = []}
</code></pre>
<p>具体的な動作は以下の通りです。</p>
<ol>
<li>現在のdependency graph上の<code>atcoder-rust-base</code>から<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#platform-specific-dependencies">現在のプラットフォームに適合する</a>、<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies">normal-dependency</a>のみで繋がれた部分グラフを求める。
そしてその節点から<code>atcoder-rust-base</code>を除いたクレートを得る。
またコマンドラインオプションで<code>-d</code>, <code>--depth</code>が指定されている場合さらにそのうちの一部に絞る。
<code>-d 1</code>を指定したならば<code>Cargo.toml</code>の<code>[dependencies]</code>にあるものだけになる。</li>
<li>コマンドラインオプションの<code>&lt;dir&gt;</code>で指定された場所に1.のうちdev-dependencyを含むもののためのワークスペースを一つ、以下の手順で作成する。
<ul>
<li>対象のクレートについて、<code>$CARGO_HOME/registory/src</code>に展開されている<code>.crate</code>ファイルの中身をコピーする。</li>
<li>このコピーしたクレートをworkspace membersとして<code>Cargo.toml</code>を作成する。
このときダミーの<code>dependencies</code>として元のnormal-dependencyとdev-dependencyをバージョンとフィーチャを指定する。</li>
<li><code>Cargo.lock</code>を<code>atcoder-rust-base</code>のもので上書きする。これで大体は元のバージョンが再現できる。</li>
</ul>
</li>
<li>1.のうちdev-dependencyを含まないものは<code>atcoder-rust-base</code>上で直接テストを実行する。</li>
<li>2.で作ったワークスペース上でテストを実行する。</li>
</ol>
<p>ワークスペースを一つにまとめることには以下の問題があり、ワークスペースを分割することで軽減できそうですがどうせ厳密なバージョン, フィーチャの保存は無理だしビルド時間と消費するディスク容量を激増させてまで分割するべきではない、と考えたため一つにまとめてしまいました。</p>
<ol>
<li>同一の名前のpackageはworkspace memberとしては共存できない</li>
<li>既存のpackageのminor, patch versionの増加</li>
<li>オフになっていたフィーチャの有効化</li>
</ol>
<h2><a class="header" href="#クレートのコンパイル" id="クレートのコンパイル">クレートのコンパイル</a></h2>
<p>クレートをコンパイルしましょう。
以下のコマンドを実行します。</p>
<pre><code class="language-console"># cd $RUST_HOME/lib
# cargo build --release
</code></pre>
<p>コンパイルに成功すると以下のように表示されます。</p>
<pre><code class="language-console"># cargo build --release
...（中略）...

Finished release [optimized] target(s) in 1m 39s
$
</code></pre>
<p><code>*.rlib</code>ファイルが作られていることを確認します。
以下のコマンドを実行します。</p>
<pre><code class="language-console">$ find target/release/deps/ -type f | egrep -c '\.(rlib|so)$'
66
# ↑ 上の数字を確認
</code></pre>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#オプションクレート検索パス生成ツールのインストール" id="オプションクレート検索パス生成ツールのインストール">（オプション）クレート検索パス生成ツールのインストール</a></h1>
<blockquote>
<p>Note: この作業は実際のビルドに<code>rustc</code>を利用する場合で、クレート検索パスを指定するコンパイルオプションをツールで生成する場合に必要となります。実際のビルドで<code>cargo</code>を利用する場合と<code>cargo build -v</code>などの出力を元にしてクレート検索パスを指定するコンパイルオプションを手書きする場合などはツールは不要です。</p>
</blockquote>
<p>このページでは<code>rustc</code>のコマンドライン・オプションを生成するツールである<code>rustc-dep-option-generator</code>のインストール手順を説明します。
このツールはRustで書かれています。</p>
<h2><a class="header" href="#依存ソフトウェアのインストール-1" id="依存ソフトウェアのインストール-1">依存ソフトウェアのインストール</a></h2>
<p>ツールが依存するシステムライブラリをインストールします。</p>
<pre><code class="language-console">$ sudo apt update
$ sudo apt install -y libssl-dev
</code></pre>
<p>なお<code>libssl-dev</code>は<code>rustc-dep-option-generator</code>が<code>cargo</code>をライブラリとして用いているために必要ですが、このツールではその機能は使いません。ツール実行時のネットワーク・アクセスは不要です。</p>
<h2><a class="header" href="#ツールのインストール" id="ツールのインストール">ツールのインストール</a></h2>
<p><code>cargo install</code>コマンドでインストールします。
以下のコマンドを実行すると、GitHubのリポジトリからツールのソースコードがダウンロードされ、ビルドが実行されます。
ビルドに成功すると、生成された実行ファイルが<code>$CARGO_HOME/bin</code>配下にインストールされます。</p>
<pre><code class="language-console">$ sudo -i

# whoami
root

# cargo install --git https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git
</code></pre>
<p>インストールの成功時は以下のように表示されます。</p>
<pre><code class="language-console"># cargo install --git https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git
    Updating git repository `https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git`
  Installing rustc-dep-option-generator v0.2.0 (https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git#...)
    Updating crates.io index
  Downloaded failure v0.1.5
   ...（中略）...

   Compiling cargo v0.35.0
   Compiling rustc-dep-option-generator v0.2.0 (https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git#...)
    Finished release [optimized] target(s) in 4m 28s
  Installing /usr/local/lib/rust/cargo/bin/rustc-dep-option-generator
</code></pre>
<h2><a class="header" href="#インストール後の動作確認-1" id="インストール後の動作確認-1">インストール後の動作確認</a></h2>
<p>ツールが動作することを確認しましょう。
以下のコマンドを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行
$ which rustc-dep-option-generator
/usr/local/lib/rust/cargo/bin/rustc-dep-option-generator

$ echo $RUST_HOME
/usr/local/lib/rust

$ rustc-dep-option-generator --help
rustc-dep-option-generator 0.2.0
rust-lang-ja Developers
A program to generate Rust compiler options to locate prebuilt crates.

USAGE:
    rustc-dep-option-generator [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --manifest-path &lt;PATH&gt;    Path to Cargo.toml
        --format &lt;FORMAT&gt;         Output format [default: shell]  [possible values: shell, json]

$ RUST_LIB=${RUST_HOME}/lib
$ rustc-dep-option-generator
--extern aho_corasick=/usr/local/lib/rust/lib/target/release/deps/libaho_corasick-aa47a24abbe125fb.rlib
--extern alga=/usr/local/lib/rust/lib/target/release/deps/libalga-8879e1bae3df17da.rlib
...（中略）...
--extern jemallocator=/usr/local/lib/rust/lib/target/release/deps/libjemallocator-f83210f5bd62bec7.rlib
-L dependency=/usr/local/lib/rust/lib/target/release/deps

## ↑ errorの文字が表示されなければOK
##
## エラーの例
## error: failed to find appropriate path for aho-corasick

$ echo $?
0   # 0ならOK
</code></pre>
<p>これでインストール作業は終了です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コンパイルコマンドと実行コマンド" id="コンパイルコマンドと実行コマンド">コンパイルコマンドと実行コマンド</a></h1>
<p>このページではジャッジサーバでユーザプログラムをコンパイルし、実行するためのコマンドを説明します。</p>
<ul>
<li><a href="atcoder-env/./compiling-and-running-using-rustc.html">rustcを利用する</a></li>
<li><a href="atcoder-env/./compiling-and-running-using-cargo.html">cargoを利用する</a></li>
</ul>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#rustc-ファイルレイアウトとコンパイルの流れ" id="rustc-ファイルレイアウトとコンパイルの流れ">[rustc] ファイルレイアウトとコンパイルの流れ</a></h1>
<p>選手がRustプログラムを提出すると、その内容がジャッジサーバ上のファイルシステムに書き出されます。
ジャッジサーバがどのような設計になっているかわからないので、ここでは仮にLinuxユーザのホームディレクトリ配下に<code>WORKAREA</code>という作業用の一時ディレクトリができるものとします。</p>
<p>Rustプログラムは<code>WORKAREA</code>の<code>main.rs</code>に書き出すようにジャッジサーバを設定してください。</p>
<pre><code class="language-console">$HOME             # ユーザのホームディレクトリ
└-- WORKAREA      # ジャッジ用の一時ディレクトリ
    └-- main.rs   # ユーザプログラム（提出されたプログラム）のソースコード
</code></pre>
<p><code>WORKAREA</code>に<code>cd</code>で移動して、後述のコンパイルコマンドを実行します。
すると以下のことが行われ<code>main</code>という名の実行ファイルが生成されます。</p>
<ol>
<li>プログラムがアセンブリコードに変換されオブジェクトファイルが作られる</li>
<li>オブジェクトファイルがRustの標準ライブラリや<code>${RUST_MOME}/lib/target/release/deps</code>配下に作成しておいた<code>rlib</code>とリンクされる</li>
</ol>
<pre><code class="language-console">$HOME
└-- WORKAREA
    |-- main.rs
    └-- main      # コンパイルとリンクの成果物。実行ファイル
</code></pre>
<h2><a class="header" href="#コンパイルコマンド" id="コンパイルコマンド">コンパイルコマンド</a></h2>
<p>ツールチェインのインストールのページで説明したように、コンパイルを実行するシェルに以下の環境変数が設定されている必要があります。</p>
<pre><code class="language-console">$ echo $RUST_HOME
/usr/local/lib/rust

$ echo $RUSTUP_HOME
/usr/local/lib/rust/rustup

$ echo $CARGO_HOME
/usr/local/lib/rust/cargo

$ echo $PATH
... /usr/local/lib/rust/cargo/bin; ...
</code></pre>
<p>コンパイルコマンドは以下のとおりです。</p>
<pre><code class="language-console">$ cd $HOME/WORKAREA
$ RUST_LIB=$RUST_HOME/lib
$ rustc --edition=2018 -C opt-level=3 \
    $(rustc-dep-option-generator $RUST_LIB/Cargo.toml $RUST_LIB/target/release/deps) \
    main.rs
</code></pre>
<p>なお<code>rustc-dep-option-generator</code>の出力は実行環境やソースには依らず、単に依存クレートの位置のみに依ります。従ってインストール時に先に<code>rustc-dep-option-generator</code>を単体で実行し、その出力を直接コンパイルオプションとして置き換えても問題ありません。こうすると毎回コンパイルのたびにこのツールを実行する必要がありません。</p>
<p>これにより<code>$HOME/WORKAREA</code>ディレクトリに<code>main</code>という名の実行ファイルが生成されます。</p>
<h2><a class="header" href="#コンパイルオプションについて" id="コンパイルオプションについて">コンパイルオプションについて</a></h2>
<p><code>rustc</code>コマンドに渡すコンパイルオプションは、Cargoでデフォルトのreleaseプロファイルを使用した時に、<code>cargo build --release</code>で生成される、ごく一般的なものを使用します。
たとえばバイナリの実行速度を最適化するためのオプションとしては<code>-C opt-level=3</code>だけを指定しています。</p>
<p>もし実行速度を追求するなら<code>-C target-cpu=native</code>のようなオプションを追加することもできます。
しかしAtCoder運営者様から以下のようなお話があったため、今回の言語アップデートでは使用しないことにします。</p>
<p><a href="https://twitter.com/chokudai/status/1138677406984691712">https://twitter.com/chokudai/status/1138677406984691712</a></p>
<blockquote>
<p>もうすぐジャッジアップデートの話を出すけれども、ジャッジの目的は「正解と不正解を分けること」であって、「最速を目指すこと」ではないので、十分に早い言語（C++, Rustなど）では、過剰な最適化とかを含めた提案はRejectすることがあるかも。</p>
</blockquote>
<p><a href="https://twitter.com/chokudai/status/1138677959059943424">https://twitter.com/chokudai/status/1138677959059943424</a></p>
<blockquote>
<p>といいつつ、言語間の差を減らすために「C++はO2とか付けない！」みたいな滅茶苦茶なことを言い出すつもりは全くなくて、「AtCoder環境がちょっと変わると動かなくなる」みたいな最適化は受け入れない、くらいの話です。</p>
</blockquote>
<p>通常形式のコンテスト（アルゴリズム系）では最速を目指すことには意味がありません。</p>
<p>一方、マラソン系のコンテストでは、たとえ数パーセントでも速度が向上するなら嬉しいことも多くあります。
AtCoderでは将来マラソン系のコンテストもRatedにする可能性があり、その際にコンパイルオプションを追加するか検討できるかもしれません（<a href="https://twitter.com/tatsuya6502/status/1140049804082311168">参考</a>）</p>
<h2><a class="header" href="#コンパイルコマンドが動作することの確認" id="コンパイルコマンドが動作することの確認">コンパイルコマンドが動作することの確認</a></h2>
<p>コンパイルコマンドが動作することを確認しましょう。
クレートのインストールに使用したCargoプロジェクトには、それらのクレートを使用する簡単なサンプルコードが含まれています。</p>
<p>以下の方法でコンパイルできます。</p>
<pre><code class="language-console">## 一般ユーザで実行

## 作業用のディレクトリを作成する

$ mkdir $HOME/WORKAREA
$ cd $HOME/WORKAREA

## サンプルコードの入ったソースファイル（2つある）をコピーする

$ RUST_LIB=$RUST_HOME/lib

$ cp -p $RUST_LIB/src/main.rs .
$ cp -p $RUST_LIB/tests/test_jemallocator.rs .

## サンプルコードをコンパイル、リンクする

$ rustc --edition=2018 -C opt-level=3 $(rustc-dep-option-generator) main.rs

$ rustc --edition=2018 -C opt-level=3 $(rustc-dep-option-generator) test_jemallocator.rs
</code></pre>
<p>コンパイルとリンクに成功すると実行ファイルが作られます。</p>
<pre><code class="language-console">$ file main
main: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),
  dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0,
  BuildID[sha1]=50373af3038c60f2a3e7a162b310e5226b08c8a9,
  with debug_info, not stripped

$ file test_jemallocator
test_jemallocator: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),
  dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0,
  BuildID[sha1]=31b718908ebf067f4b1161b1dc5cf679f012ad7f,
  with debug_info, not stripped
</code></pre>
<h1><a class="header" href="#実行コマンド" id="実行コマンド">実行コマンド</a></h1>
<p>実行ファイルを実行するコマンドは以下のとおりです。</p>
<pre><code class="language-console">$ cd $HOME/WORKAREA
$ ./main
</code></pre>
<h2><a class="header" href="#実行コマンドが動作することの確認" id="実行コマンドが動作することの確認">実行コマンドが動作することの確認</a></h2>
<p>実行コマンドが動作することを確認しましょう。
先ほど作成した実行ファイルを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行

$ cd $HOME/WORKAREA

$ ./main
...

## いろいろなメッセージが表示されるが、テスト用の出力なので内容は確認しなくてよい
## 終了コード0で終了したことだけを確認すればOK

$ echo $?
0

$ ./test_jemallocator
...

## こちらも終了コード0で終了したことだけを確認すればOK
$ echo $?
0
</code></pre>
<p>AtCoder運営者向けの情報は以上となります。
内容について質問などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#cargo-ファイルレイアウトとコンパイルの流れ" id="cargo-ファイルレイアウトとコンパイルの流れ">[cargo] ファイルレイアウトとコンパイルの流れ</a></h1>
<p>選手がRustプログラムを提出すると、その内容がジャッジサーバ上のファイルシステムに書き出されます。
ジャッジサーバがどのような設計になっているかわからないので、ここでは仮にLinuxユーザのホームディレクトリ配下に<code>WORKAREA</code>という作業用の一時ディレクトリができるものとします。</p>
<p>まずは先ほど依存クレートをコンパイルするのに利用したプロジェクトのディレクトリを、そっくり<code>WORKAREA</code>内に丸ごとコピーしてください。依存クレートをコンパイルするのに利用したプロジェクトは、本書の通りにセットアップした場合<code>/usr/local/lib/rust/lib</code>となっているはずです。</p>
<pre><code class="language-console">$HOME                      # ユーザのホームディレクトリ
└-- WORKAREA               # ジャッジ用の一時ディレクトリ
    └-- lib                # 全部入りプロジェクトをまるまるコピーしたもの
        |-- main.rs        # ユーザプログラム（提出されたプログラム）のソースコードに置き換える
        |-- Cargo.toml
        └-- target
            └-- release
                |-- deps   # (外部クレートのコンパイルキャッシュ)
                └-- atcoder-rust-base # コンパイル、リンク済みの実行ファイル
</code></pre>
<p>そして、この<code>WORKAREA/lib/main.rs</code>をユーザーが入力したファイルにそっくりそのまま置き換えます。</p>
<p>以上でCargoプロジェクトが整いました。</p>
<h2><a class="header" href="#コンパイルコマンド-1" id="コンパイルコマンド-1">コンパイルコマンド</a></h2>
<p>ツールチェインのインストールのページで説明したように、コンパイルを実行するシェルに以下の環境変数が設定されている必要があります。</p>
<pre><code class="language-console">$ echo $RUST_HOME
/usr/local/lib/rust

$ echo $RUSTUP_HOME
/usr/local/lib/rust/rustup

$ echo $CARGO_HOME
/usr/local/lib/rust/cargo

$ echo $PATH
... /usr/local/lib/rust/cargo/bin; ...
</code></pre>
<p>コンパイルコマンドは以下の通りです。</p>
<pre><code class="language-console">$ cd $HOME/WORKAREA/lib
$ cargo build --release --offline
</code></pre>
<p>すると<code>$HOME/WORKAREA/lib/target/release</code>ディレクトリに<code>atcoder-rust-base</code>という名前の実行ファイルが生成されます。</p>
<h2><a class="header" href="#コンパイルオプションについて-1" id="コンパイルオプションについて-1">コンパイルオプションについて</a></h2>
<p>Cargoを利用する場合、ネットワーク接続がない環境でも安定して動作させるため、<code>--offline</code>オプションを利用します。それ以外は、通常のRustプロジェクトのビルドと同様です。</p>
<h2><a class="header" href="#コンパイルコマンドが動作することの確認-1" id="コンパイルコマンドが動作することの確認-1">コンパイルコマンドが動作することの確認</a></h2>
<p>実際のコンテストでは<code>WORKAREA/lib/main.rs</code>ファイルをユーザーの入力でそっくり置き換えて実行するのですが、置き換える前の<code>WORKAREA/lib/main.rs</code>には各依存クレートに対応する簡単なテストコードが含まれています。<a href="atcoder-env/./installing-rust-crates.html#%E3%82%AF%E3%83%AC%E3%83%BC%E3%83%88%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88">クレートをインストールした際に確かめたのと同様の方法で</a>このファイルがコンパイルできることを確かめましょう。</p>
<p>まずは動作の確認です。</p>
<pre><code class="language-console">$ cargo test --release
   Compiling atcoder-rust-base v0.1.0 (...)
    Finished release [optimized] target(s) in 7.31s
     Running target\release\deps\...

running 11 tests
test test_ascii ... okYes
Yes

test test_bitset_fixed ... ok
test test_modtype ... ok
test test_ordered_float ... ok
test test_permutohedron ... ok
test test_itertools ... ok
test test_rand_family ... ok
test test_proconio ... ok
test test_regex ... ok
test test_rustc_hash ... ok
test test_superslice ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>多少表示されるテストの個数は異なるかもしれませんが、一番下の行が<code>test result: ok.</code>で<code>0 failed;</code>となっていれば問題ありません。</p>
<p>続いてコンパイルができることを確認します。</p>
<pre><code class="language-console">$ cargo build --release --offline
(...略...)
    Finished release [optimized] target(s) in 0.86s
</code></pre>
<p>上のように<code>Finished</code>が出力されれば、実行可能バイナリが<code>$HOME/WORKAREA/lib/target/release/atcoder-rust-base</code>に生成されているはずです。</p>
<h2><a class="header" href="#実行コマンドが動作することの確認-1" id="実行コマンドが動作することの確認-1">実行コマンドが動作することの確認</a></h2>
<p>実行コマンドが動作することを確認しましょう。
先ほど作成した実行ファイルを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行

$ cd $HOME/WORKAREA

$ target/release/atcoder-rust-base
...

## いろいろなメッセージが表示されるが、テスト用の出力なので内容は確認しなくてよい
## 終了コード0で終了したことだけを確認すればOK

$ echo $?
0
</code></pre>
<p>AtCoder運営者向けの情報は以上となります。
内容について質問などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コントリビュータ" id="コントリビュータ">コントリビュータ</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
