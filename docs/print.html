<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AtCoderコンテストにRustで参加するためのガイドブック</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> はじめに (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">2.</strong> AtCoderの環境について (TODO)</a></li><li><ol class="section"><li><a href="todo.html"><strong aria-hidden="true">2.1.</strong> ソフトウェアのバージョンなど (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">2.2.</strong> 単一のソースファイル (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">2.3.</strong> 利用可能なクレート (TODO)</a></li></ol></li><li><a href="todo.html"><strong aria-hidden="true">3.</strong> 開発環境の準備 (TODO)</a></li><li><ol class="section"><li><a href="todo.html"><strong aria-hidden="true">3.1.</strong> Rustツールチェインのインストール (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">3.2.</strong> ソースコードエディタとデバッガの準備 (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">3.3.</strong> cargo-generateテンプレート (TODO)</a></li><li><ol class="section"><li><a href="todo.html"><strong aria-hidden="true">3.3.1.</strong> cargo-generateのインストール (TODO)</a></li></ol></li></ol></li><li><a href="todo.html"><strong aria-hidden="true">4.</strong> コンテストの参加方法 (TODO)</a></li><li><ol class="section"><li><a href="todo.html"><strong aria-hidden="true">4.1.</strong> Cargoパッケージの作成 (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">4.2.</strong> 利用するクレートの選択 (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">4.3.</strong> テストケースの作成 (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">4.4.</strong> プログラムの作成 (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">4.5.</strong> プログラムのテスト (TODO)</a></li><li><a href="todo.html"><strong aria-hidden="true">4.6.</strong> プログラムの提出 (TODO)</a></li></ol></li><li><a href="todo.html"><strong aria-hidden="true">5.</strong> Tips（小技集） (TODO)</a></li><li><ol class="section"><li><a href="todo.html"><strong aria-hidden="true">5.1.</strong> クレートの使用例 (TODO)</a></li></ol></li><li><a href="atcoder-env/index.html"><strong aria-hidden="true">6.</strong> AtCoder運営者向けの情報</a></li><li><ol class="section"><li><a href="atcoder-env/supported-environment.html"><strong aria-hidden="true">6.1.</strong> 本章で想定している環境</a></li><li><a href="atcoder-env/installation.html"><strong aria-hidden="true">6.2.</strong> インストール</a></li><li><ol class="section"><li><a href="atcoder-env/installing-rust-toolchain.html"><strong aria-hidden="true">6.2.1.</strong> Rustツールチェインのインストール</a></li><li><a href="atcoder-env/installing-rust-crates.html"><strong aria-hidden="true">6.2.2.</strong> クレートのコンパイルとインストール</a></li><li><a href="atcoder-env/installing-rustc-dep-option-generator.html"><strong aria-hidden="true">6.2.3.</strong> （オプション）クレート検索パス生成ツールのインストール</a></li></ol></li><li><a href="atcoder-env/compiling-and-running-program.html"><strong aria-hidden="true">6.3.</strong> コンパイルコマンドと実行コマンド</a></li><li><ol class="section"><li><a href="atcoder-env/compiling-and-running-using-rustc.html"><strong aria-hidden="true">6.3.1.</strong> rustcを利用する</a></li><li><a href="atcoder-env/compiling-and-running-using-cargo.html"><strong aria-hidden="true">6.3.2.</strong> cargoを利用する</a></li></ol></li></ol></li><li><a href="contributors.html"><strong aria-hidden="true">7.</strong> コントリビュータ (TODO)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">AtCoderコンテストにRustで参加するためのガイドブック</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#はじめに" id="はじめに">はじめに</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>
<p>本書はAtCoderのコンテストにRustで参加するためのガイドブックです。</p>
<h2><a class="header" href="#atcoderとは" id="atcoderとは">AtCoderとは？</a></h2>
<p>AtCoderは、オンラインで参加できるプログラミングコンテスト(競技プログラミング)のサイトです。リアルタイムのコンテストで競い合ったり、約3000問のコンテストの過去問にいつでも挑戦することが出来ます。 (<a href="https://atcoder.jp/">AtCoderのトップページ</a>より引用)</p>
<p><strong>Note:</strong> 競技プログラミングはプログラミングで解決できるような問題をなるべく早く正確に解く競技です。競技プログラミングについてよく知らないが興味があるという方は、インターネット上に初心者向けの詳しい情報がたくさんありますので検索してみてください。AtCoderで開催されているものでは、大きく分けて二種類あります。</p>
<ul>
<li>与えられる問題に対して、その解を出力するようなプログラムを書く競技 (アルゴリズム系)
<ul>
<li>定期開催のもの: AtCoder Beginner Contest (ABC), AtCoder Regular Contest (ARC), AtCoder Grand Contest (AGC) があり、難易度は通常 ABC &lt; ARC &lt; AGC です。</li>
<li>定期開催の他、企業によって開かれるコンテストもあります。そういったコンテストで上位成績をとると、その企業への就職、インターン、アルバイトなどで多少優遇されることがあります (コンテストによります) 。</li>
<li>例: 「整数<code>N</code>が与えられます。<code>N</code>以下の正整数から等確率に1つを選ぶとき、それが奇数になる確率を求めなさい」 (AtCoder Beginner Contest 142 A問題)</li>
<li>例: 「<code>N</code>人の身長が与えられます。<code>K</code>cm以上の人の人数を出力してください」 (AtCoder Beginner Contest 142 B問題)</li>
</ul>
</li>
<li>与えられる問題に対して、少しでも良い解を出力するようなプログラムを書く競技 (マラソン系)
<ul>
<li>定期開催のものはまだありません。企業が自社の取り組みやそこでの課題をテーマに出題することが多いようです。</li>
<li>例: 「ある観測データが与えられるので、可能な限り圧縮するプログラムとそれを解凍するプログラムを書いてください」 (Wethernews Programming Competition)</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#なぜrustなのか" id="なぜrustなのか">なぜRustなのか？</a></h2>
<p>AtCoderで使える言語は非常にたくさんあります。どの言語を使ってもよいですし、問題によって使い分けても構いません。その中でなぜRustを使うのか、そのメリットとデメリットをまとめてみました。できるだけ一般論で比較するよう心がけますが、競技プログラミングにおけるC++人口がそれなりに多いことと、Rustはその特性上C++と比較されることが多いので、具体的にC++との比較になっている部分も多くあります。</p>
<h3><a class="header" href="#メリット" id="メリット">メリット</a></h3>
<h4><a class="header" href="#高速である" id="高速である">高速である</a></h4>
<p>AtCoder含め、競技プログラミングでは「実行時間制限」とよばれるものがあります。この時間内にプログラムの実行が終わらないと「TLE (Time Limit Exceeded)」という判定が付いて誤答扱いとなります。多くの場合は想定されている解法であれば多少の余裕をもって解けるように設定されていますが、非常にたくさんの言語が使える都合上全ての言語で公平になるようにはできません。遅い言語に合わせて設定すると速い言語では強引な解法でゴリ押しできてしまうことがありますし、速い言語に合わせると遅い言語では想定されている解法でも通せないということになります。いずれにせよ、基本的には速い言語であるほうが計算時間的には有利です。 (もちろん遅い言語と言われるものにも、例えば書き易さであったり、ライブラリが充実していたり、なにかしらのメリットがあるはずです。どちらかが絶対的に有利ということではありません。)</p>
<p>Rustは最速と言われるC/C++並みに速いとされていますので、(少なくともAtCoderでは) 速度面で不利になることはないと言えるでしょう。</p>
<h4><a class="header" href="#信頼性が高い" id="信頼性が高い">信頼性が高い</a></h4>
<p>信頼性は、ここではRustの<a href="https://www.rust-lang.org/">公式トップページ</a>に倣いメモリ安全性、スレッド安全性、バグの起こしにくさであるとします。競技プログラミングで特に大事になってくるのはメモリ安全性とバグの起こしにくさです。</p>
<blockquote>
<p><strong>Reliability</strong> Rust’s rich type system and ownership model guarantee memory-safety and thread-safety — and enable you to eliminate many classes of bugs at compile-time.</p>
</blockquote>
<p>これは様々なプログラミング言語が様々なアイデアで対処している部分です。たとえばメモリの確保と解放を正しく行うために、C++であればスマートポインタやコンテナを用意したり、他の言語ではガベージコレクタという実行時の機構を用意したりしています。RustでもC++のスマートポインタやコンテナと同様なものを用意し、自分でメモリの確保と解放を行わなくてよいようにできています。ガベージコレクタを利用すると確かに安全でメモリ管理に関してほとんど何も考えなくてよいものの、そのためにほとんどのデータをヒープに置いて参照経由で扱わなければならず、実行速度にも多少影響します。かといってC++のスマートポインタやコンテナは間違った使い方が簡単にできてしまいます。特にイテレータはコレクションに対する操作を行うための標準的なツールにもかかわらず実質的に単なるポインタと同様なので、しばしば無効なイテレータが発生します。例えば (少々意図的な例ですが) 次のように簡単に問題を起こせてしまいます。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std::string_literals;
int main() {
    std::vector&lt;std::string&gt; v = {&quot;hello&quot;s, &quot;world&quot;s};
    v.shrink_to_fit();
    for (auto const &amp;i: v) {
        if (i == &quot;hello&quot;) v.push_back(&quot;c++&quot;s); // イテレータを無効化してしまう
        // 未定義動作なので、プログラム全体が何を起こすか分からない
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}
</code></pre>
<p>このようなことはRustではコンパイルエラーとしてコンパイル時に検出されます。</p>
<pre><code class="language-rust ignore">let mut v = vec![&quot;hello&quot;, &quot;world&quot;];
for &amp;i in &amp;v {
    if i == &quot;hello&quot; {
        v.push(&quot;rust&quot;);
        // E0502: cannot borrow `v` as mutable because it is also borrowed as immutable
        // 4 | for &amp;i in &amp;v {
        //   |           --
        //   |           immutable borrow occurs here
        //   |           immutable borrow later used here
        // 5 |     if i == &quot;hello&quot; {
        // 6 |         v.push(&quot;rust&quot;);
        //   |         ^^^^^^^^^^^^^^ mutable borrow occurs here
    }
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>また、複雑なアルゴリズムにバグはつきものです。例えば、添字計算をしていてちょっとした書き間違いで配列のサイズを超えたところを参照してしまったといったことは度々起こりえます。こういうとき、例えばC/C++では配列外参照をしてしまったプログラムがどのように動作するかの保証がなく、<code>segmentation fault</code>とだけ表示されて異常終了したり、たまたまうまくいってしまったり、手元で正解するケースがサーバーでは誤答となったりし得ます。こういったよく分からない動作が起きてしまうとバグの原因特定が難しくなったり無関係なところを原因と思い込んだりしてしまい、デバッグにかなりの時間を費やしてしまうこともしばしばあります。この配列外参照の例ではRustは必ずエラーを起こしますし、どこで起こしたかも表示してくれます。それが自分のコードでない場合でも (<code>-g</code>オプション付きでビルドされたかCargoでデバッグビルドされたバイナリであれば) バックトレースを表示させることで呼出元となる自分のコードを特定できます。</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let x = vec![1, 2, 3];
let y = 3;
let _z = x[y]; // 配列外参照!
#}</code></pre></pre>
<pre><code class="language-text">thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3', ...
stack backtrace:
  (...中略...)
  16: alloc::vec::{{impl}}::index&lt;i32,usize&gt;
             at ...
  17: test::main
             at .\test.rs:4
  (...中略...)
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<h4><a class="header" href="#多くの問題をコンパイル時に発見できる" id="多くの問題をコンパイル時に発見できる">多くの問題をコンパイル時に発見できる</a></h4>
<p>RustはC/C++並みの速度を確保するため、実行時にやらなければいけないことをなるべく減らす方針の言語です。たとえば先ほど触れたように、多くの言語にあるガベージコレクタがありません。それだけならばC++と変わりありませんが、速度と安全性を両立させるためにRustではできるだけ多くのことをコンパイル時に確認する仕組みになっています。C++が受け入れてしまうような危険なコードもコンパイルエラーにします。</p>
<p>それ以外にも、例えば整数型同士の暗黙の型変換がない (例え<code>u8</code>から<code>u32</code>であっても) こともある種のミスを防ぐのに役立ちます。たとえばC++で総和をとるために<code>accumulate()</code>関数を利用する際、気をつけなければオーバーフローしないはずのところでオーバーフローを起こしてしまいます (もし符号付き整数型であったなら未定義動作にもなってしまいます) 。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main() {
    // long long で表せる最大値を`large`とする。
    long long large = std::numeric_limits&lt;long long&gt;::max();

    std::vector&lt;long long&gt; s = {large};

    // sには`large`しか入っていないので、総和は普通に`large`になるはず。ところが
    // 総和の型をint型だと思って計算してしまいオーバーフローを起こしてしまう。特
    // に何のエラーもなし。
    std::cout &lt;&lt; std::accumulate(s.begin(), s.end(), 0) &lt;&lt; std::endl;

    // 正しくは以下の通り。
    std::cout &lt;&lt; std::accumulate(s.begin(), s.end(), 0ll) &lt;&lt; std::endl;
}
</code></pre>
<p>Rustではこのようなことは最初から型の不一致によりコンパイルエラーとなります。</p>
<pre><code class="language-rust ignore">let s = vec![std::i64::MAX];
let x: i32 = s.into_iter().sum();
// E0277: the trait bound `i32: std::iter::Sum&lt;i64&gt;` is not satisfied
// 3 | let x: i32 = s.into_iter().sum();
//   |                            ^^^ the trait `std::iter::Sum&lt;i64&gt;` is not implemented for `i32`
</code></pre>
<p>ジェネリクスとトレイトの仕組みも強力です。たとえばジェネリックな関数が型変数<code>T</code>をもつとき、この<code>T</code>のとりうる型を特定のトレイト (＝機能一覧) を実装しているものだけに制限することができます。逆に<code>T</code>に対してできることはその特定のトレイトが定める機能のみです。従って、一度コンパイルが通った関数はその制約を満たす限りのどのような<code>T</code>を与えても関数の内部でコンパイルエラーとなることはありません。特にライブラリを整備するにあたってはこれはとてもありがたいことです。実際に使ってみなくても、コンパイルさえ通れば、将来的に作られうるどんなユーザー定義型を与えようともその関数が正しく呼び出せることが保証されます。C++のテンプレートなどでは実際に具体的な型を与えて始めて様々な検証をするので、使う段階になってからでないとエラーが発見できません。このことは、後述するコンパイルエラーの分かりやすさにも繋がっています。</p>
<h4><a class="header" href="#コンパイルエラーが分かりやすい" id="コンパイルエラーが分かりやすい">コンパイルエラーが分かりやすい</a></h4>
<p>これは少々主観的な話になるのかもしれませんが、Rustのコンパイルエラーは読みやすく分かりやすいという評判があります。実際にコンパイルエラーが発生したとき、まずエラーが起きた場所はもちろんとして、エラーが関連する他の場所 (例えば以前に借用された場所など) などをアスキーアート的な手法で視覚的に分かりやすく表示してくれます。さらに、なぜそれが間違っているのか/それをどのように修正することができるかのヒントが提示されることもあります。例えば、先ほどのエラー全体は次のようになっていました。</p>
<pre><code class="language-console">error[E0277]: the trait bound `i32: std::iter::Sum&lt;i64&gt;` is not satisfied
--&gt; (filename):3:32
|
3 |     let x: i32 = s.into_iter().sum();
|                                ^^^ the trait `std::iter::Sum&lt;i64&gt;` is not implemented for `i32`
|
= help: the following implementations were found:
            &lt;i32 as std::iter::Sum&lt;&amp;'a i32&gt;&gt;
            &lt;i32 as std::iter::Sum&gt;

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>先ほど少し触れたように、トレイト/ジェネリクスの仕組みによりエラーの所在が明確化されています。関数が呼び出せないのは引数に関数が設定した制約を満たさないものを与えているからだと分かります。動的型付け言語やC++のテンプレートでは、仕組み上実際に実行または実体化してみなければエラーの存在が分かりませんので、与えられた引数が関数の求める条件を満たしていなかったのか関数の方に根本的な書き間違いがあるのかがインタプリタ/コンパイラには分かりません。必然的に実際にエラーを起こしたライブラリの内部の実装部分を指し示しながら、ここで呼び出されていて、ここで呼び出されていて、...と辿っていくしかなく、しかもそのうちのどれが悪いのかが分からないので関係がありそうなところを全て表示していくしかありません。</p>
<p>一部のエラーには詳細な説明が用意されており、<code>rustc --explain (エラーコード)</code>とすることにより、そのエラーが何を言っているのか/どういうコードでそのエラーが発生するのかなどをもりこんだ詳細な解説を読むこともできます。たとえば上のエラーの<code>E0277</code>にも用意されています。</p>
<pre><code class="language-console">$ rustc --explain E0277
You tried to use a type which doesn't implement some trait in a place which
expected that trait. Erroneous code example:

```
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}
```
(以下略)
</code></pre>
<h4><a class="header" href="#抽象化のための機能を数多く備えている" id="抽象化のための機能を数多く備えている">抽象化のための機能を数多く備えている</a></h4>
<p>例えば次のようなさまざまな機能があります。Rustは後発の言語ですので、他のプログラミング言語に備わっている優れた機能も参考にして多数の機能が導入されています。</p>
<ul>
<li>
<p>強力な型推論</p>
<p>型推論アルゴリズムとしては非常に有名なHindley/Milnerのアルゴリズムをベースにした賢い型推論器を持ちます。言語設計的に型推論を制限している箇所 (例: 関数の引数) や、型推論だけでは決定できず型を明示する必要があることもあります (例: <code>iter.collect::&lt;Result&lt;_, _&gt;&gt;()?</code>) 。それでもほとんどのケースでは推論され、型の明示は最低限で済みます。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">代数的データ構造</a></p>
<p>Rustの列挙型 (<code>enum</code>)は各バリアントに値を持てます。いわゆる直和型や代数的データ型と呼ばれるものです。タグ付き共用体 (tagged union) と呼ばれることもあります。例えば一方向連結リストの構造は次のように表せます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum List&lt;T&gt; {
    /// 先頭要素とそれ以降の要素によるリストを持つ。
    Cons(T, Box&lt;List&lt;T&gt;&gt;),

    /// リストが空であることを示す。
    Nil,
}
#}</code></pre></pre>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">トレイト</a></p>
<p>JavaやC#のインターフェイスと似ていますが、より柔軟に利用することができます。Rustではいわゆる「オブジェクト指向言語」が持つ継承の仕組みをもたない代わりに強力な列挙型とトレイトの仕組みを活用します。例えば単純な継承関係であれば次のような方法で置き換えられます。多くの場合、1.と2.を用いれば十分対応できることでしょう (<a href="https://twitter.com/i/web/status/928550702720233472">参考</a>) 。</p>
<ol>
<li>
<p>実装クラスが数個かつパラメータも多くはない</p>
<p>列挙型 (直和型)を使います。
むしろこのような場合は最初から継承よりも直和型が適切である場合が多いです。
実際、KotlinやScalaではJVM上で抽象クラスとそのサブクラスを直和型のように扱うためにsealed classという機能を備えています。</p>
</li>
<li>
<p>実装の共有</p>
<p>トレイトのデフォルト実装を使います。
フィールドの共通化は、代わりにgetterメソッドをトレイトに記述しておきます。
むしろこれにより各フィールドやメソッドの役割が明確になり、無意味に複雑なコードが生まれにくくなります。</p>
<p>ただし、getterを書く際に「1つのオブジェクトに対する可変参照は高々1つしか存在できない」という原則が障害となることがごく稀にあります。</p>
</li>
<li>
<p>特定のメソッドだけ必要</p>
<p>trait object (<a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code>Box&lt;_&gt;</code></a>)でdynamic dispatchを行ないます。</p>
</li>
</ol>
<p>なお、<a href="https://doc.rust-lang.org/stable/std/?search=Deref"><code>Deref</code></a>と<a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>トレイトを実装すると、メソッド呼出時に自動的に対象の型への型変換が行われ、簡単に対象の型のメソッドを呼び出すことができるようになります。これを継承における「親クラスからのメソッドの受け継ぎ」に転用することは可能ですが、これはアンチパターンとされることも多いです (<a href="https://github.com/rust-unofficial/patterns/blob/master/anti_patterns/deref.md">参考</a>) 。</p>
<p>その他また、Rustのトレイトは型クラスのように考えることもできます (<a href="https://keens.github.io/slide/katakurasuwokoete/">参考</a>) 。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching">パターンマッチング</a></p>
<p>パターンマッチングは、端的に言うならばタプルや構造体・列挙型などを (構造に合わせて分岐しながら) 分解し、中身を取り出す機能です。特に先に触れた列挙型を扱うにあたっては、パターンマッチは非常に強力な機能です。最近でも少しずつ改善が行なわれており、 Rust 1.26で<a href="https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html">slice pattern</a>が追加されたり1.39で<a href="https://github.com/rust-lang/rust/pull/63118/"><code>if</code>の制限の取り払われたり</a>しました。これらの改善もあり、特にML系言語に馴染みのある方は近い感覚で扱えるのではないでしょうか。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch19-06-macros.html"><strong>衛生的</strong>マクロ</a></p>
<p>衛生的とは識別子が衝突する心配がないことです。マクロ内で宣言されたローカル変数がマクロ外から参照できてしまうことも、その逆にマクロ内で参照する変数がたまたま展開先のローカル変数を参照してしまうこともありません。また、マクロの各引数が何を受け取るのかを指定することができるため、例えば式を受け取ると指定すればその引数はひとまとまりの式として扱われます。この式の値を利用するときに、前後の関係で式としての解釈が壊れることもありません (例えば <code>$x = 1 + 2</code> のとき <code>2 * $x</code> は <code>2 * 1 + 2</code> ではなく <code>2 * (1 + 2)</code> に相当します) 。</p>
<p>このように、Rustのマクロは積極的に利用しても比較的安全です。特にRustでは多くなりがちなボイラープレートを短くまとめるなど役に立つ機会も多いでしょう。またマクロの入力はパターンマッチで行われるため受け付ける文法が比較的自由であり、この後に述べるRustのデメリットのうち特に冗長性に関わることは可読性を保ったままマクロで解決できることも多いです。</p>
</li>
<li>
<p>block expression</p>
<p>block expression とはブロックを式として扱える仕組みのことです。ブロックの式としての値はそのブロックの末尾にある式の値になります。これがあると、例えば別の変数の初期化にしか使わない一時変数のスコープを絞ることができます。地味ではありますが、あると便利に感じる機能です。</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">シャドーイング (の推奨)</a></p>
<p>一般的にシャドーイングはすべきでないとされる傾向がありますが、Rustではむしろシャドーイングが推奨されています。
これにより、たとえば処理の途中で一度変数に格納するときにもわざわざprefixやsuffixが付いた別の変数を宣言しなくて良くなりますし、あるいは再束縛することで不要になった<code>mut</code>を消すこともできます。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// この配列を数値にしてかつソートしたい
let list = vec![&quot;2&quot;, &quot;4&quot;, &quot;1&quot;, &quot;5&quot;, &quot;3&quot;];
let list = list.into_iter().map(|x| x.parse().unwrap());
// ソートしたいので mut とする
let mut list: Vec&lt;i32&gt; = list.collect();
list.sort();
let list = list; // ソートしたので mut は不要、消す
// list.push(4); // =&gt; 既に mut ではないので変更できない
assert_eq!(list, [1, 2, 3, 4, 5]);
#}</code></pre></pre>
<p>一般にシャドーイングするべきではないとされる理由は様々にありますが、一番はやはり混同しやすくなるからと考えられます。その点Rustは強い静的型付け言語ですので、仮に混同したとしてもどこかのタイミングで型エラーになるという期待ができます。</p>
<p>また、変数の個数を抑止するという効果もあります。block expression等と適宜組み合わせることで変数の数やスコープはさらに小さく保つことができ、多少関数の実装が長くなっても見通しが悪くなりにくいと言えます。競技プログラミングではmain関数が長くなりがちなので一層嬉しいのではないでしょうか。</p>
</li>
</ul>
<h4><a class="header" href="#ゼロコスト抽象化を追求している" id="ゼロコスト抽象化を追求している">ゼロコスト抽象化を追求している</a></h4>
<p>Rustの言語デザインやライブラリは、一定の使いやすさを実現しつつも、使いやすさのために実行時の高速性を犠牲にはしないという<strong>ゼロコスト抽象化</strong> (<em>zero-cost abstraction</em>)を追求しています。</p>
<p>他の言語では「イテレータではなくfor文で書いた方が速い」、「async/awaitを使うと遅い」といったことは珍しくありません。これはその言語の選択で、動作が遅くなるとしてもコードを簡潔に簡単に書けることを優先したと言えます。一方でRustでは抽象化によってパフォーマンスが犠牲になるのなら、その抽象化はできるだけ採用しません。最適化の余地 (自由度) を残すためには関数群は基礎的なものにとどめる必要があり、特定の機能を実現するために冗長なコードを書く必要があります。結果的にコードは長く面倒になり手間もかかりますが、そうしてでもパフォーマンスをとることができるように設計されています。</p>
<p>このことは「簡潔な構文や関数によってその機能が必要とするコストを隠してしまう」ことを避けているとも言えます。つまり、本当にパフォーマンスが必要なときに最適化を検討するべき「コスト」の部分が明確化されているということでもあります。</p>
<h3><a class="header" href="#デメリット" id="デメリット">デメリット</a></h3>
<h4><a class="header" href="#現れる概念が比較的難しい" id="現れる概念が比較的難しい">現れる概念が比較的難しい</a></h4>
<p>先に見たように、Rustでは、いままで他の言語ではコンパイラが検証していなかったようなことをコンパイル時に検証します。そのためにRustでは所有権や借用をはじめとする独特の概念が導入されており、それらの概念の理解そのものが難しいとされることも多いようです。これらの概念が課す多数のルールがなぜ存在するのかを理解することは、仕組みをある程度理解していなければ難しいものです。</p>
<p>たとえば要素への参照をもったまま<code>Vec</code>本体の可変参照をとることはできませんが、これは可変参照と共有参照は同時に存在できないというルールからです。ではなぜこのようなルールがあるのでしょうか。たとえば<code>Vec</code>に要素を追加するとキャパシティが足りないときにメモリの再確保とデータの移動が行われるので、無効な参照が生み出せてしまうからです。しかしこういった事情を知らないと、単にRustがよく分からない制約を課してくるだけの書きにくい言語だと感じてしまうかもしれません。一方でこの難しさを隠せている言語もあります。たとえばJavaやC#などオブジェクトを参照で扱うような言語では、要素への参照を得ても単にそのオブジェクトへの参照が一つ増えるだけで、可変長配列の領域そのものへの参照を得るわけではないということもあるかもしれません。そのような言語では、要素そのものは可変長配列が管理するメモリ上にあるわけではないので、要素への参照をもったまま可変長配列を伸ばしても問題は起こりません。そのかわり、おそらく別の部分の犠牲 (アクセスに必ず参照を介することのコストであったり、参照型と値型の挙動の違いによる難しさであったり) があります。</p>
<p>Rustが課すルールにも理由がありますので、そういった事情について意識的に考えることは他の言語や競技プログラミング以外の文脈でも活きる有意義なものではあると思います。単にAtCoderである程度の競技プログラミングをするだけであれば、C#やJavaといった言語でもほぼ正解できるよう調整されているようなので、どちらを取るかは好みといっていいかもしれません。</p>
<h4><a class="header" href="#素早く書くことにはあまり向かない仕様" id="素早く書くことにはあまり向かない仕様">素早く書くことにはあまり向かない仕様</a></h4>
<p>Rustの安全指向や標準ライブラリの設計方針などは、時間をかけて大規模なプログラムを書くときや堅牢なプログラムを書くときには非常に役に立ちます。一方で競技プログラミングでは、一般のプログラミングと異なり、次のような特徴があります。</p>
<ul>
<li>早くプログラムを完成させることが重要</li>
<li>入力のフォーマットや扱う値の範囲・個数などが定まっている</li>
<li>スレッドを起動してやりとりするようなことは通常ない</li>
<li>後日提出したプログラムを見直したり保守することは通常ない (ライブラリを除く)</li>
</ul>
<p>したがって、Rustの様々な設計は、必要以上に煩雑に感じることがあります。例えば、Rustでの競技プログラミングを始めようとした方で、標準入力をとるのがとても面倒で挫折し (かけ) た、という方も度々見かけます。例えば、空白区切り二つの整数を読み取ってその和を計算するプログラムは、工夫をしなければ次のようになります。</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn main() {
    let (a, b) = {
        let mut s = String::new();
        std::io::stdin().read_line(&amp;mut s).unwrap();
        let mut iter = s.split_whitespace().map(|i| i.parse::&lt;i32&gt;().unwrap());
        (iter.next().unwrap(), iter.next().unwrap())
    };

    println!(&quot;{}&quot;, a + b);
}
</code></pre></pre>
<p>「二つの空白区切りの数字を読むだけでこれほど多くのコードが必要なのか」と思われるかもしれませんが、こうなっているのには次のような設計があります。</p>
<ul>
<li>空白区切りの入力を任意の型の値として読み込むことができない。
<code>std</code>には整数を読む機能などはなく、かならず一行単位 (<code>read_line()</code>) または全体 (<code>read_to_string()</code>) を文字列として読んでから処理する必要があります。なお<code>read_to_string()</code>を使うときは、<code>use std::io::Read;</code>が必要であることと、手元でテストするときにEOF (<code>Ctrl + D</code> (macOSやLinux) または<code>Ctrl + Z</code> (Windows)) を入力するまで入力が終了しないこと、に注意が必要です。</li>
<li>入力はバッファをとって、そこに書き込む。
<code>read_line(&amp;mut s)</code>の部分にあたります。入力を<code>String</code>に入れて返す関数よりも、バッファを受けとって書き込む方式の方が、必要に応じてバッファを事前にアロケートしておける分、パフォーマンス的には柔軟なのです。とはいえ競技プログラミングでは高々O(log n)回のリアロケーション (この挙動はドキュメント化されていないため変わる可能性もなくはありませんが) にかかるコストを気にする必要はないと思われます。</li>
<li>イテレータを上手に扱う必要がある。
受け取った文字列を空白区切りにするためには<code>split_whitespace()</code>という関数を使いますが、これはイテレータを返します。その各要素を整数に変換するために<code>map()</code>と<code>parse()</code>関数を使いますが、変換先の型を指定するために<code>parse::&lt;i32&gt;()</code>などの書き方を使う必要があります。<a href="https://crates.io/crates/itertools"><code>itertools</code></a> を使えば<a href="https://docs.rs/itertools/0.8.2/itertools/trait.Itertools.html#method.next_tuple">イテレータを直接分解するような書き方ができますが</a> 、<code>std</code>に限れば一つずつ<code>next()</code>で要素を取り出すしかありません。</li>
<li><code>std</code>を含む各ライブラリは大抵明示的なエラーハンドリングを要求する。
<ul>
<li>何かの理由で標準入力が読み込めない状態になるかもしれません。整数ではない入力を整数にしようとするかもしれません。イテレータの要素が足りないかもしれません。こういったものをRustでは<a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a>や<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>で表現します。<a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><code>?</code></a>を使えば視認性を損ねることはない (むしろコードを俯瞰するときのの助けになる) ですが競技プログラミングでは<code>unwrap()</code>を使うことになるでしょう。これはエラーが起きたならパニック (i.e. <code>RE</code>) するという乱暴なものですが、入力の形式が決まっている以上エラーになるのは読み間違えたか書き間違えたときのみでしょう。</li>
<li>もちろん逆に、明示的なエラーハンドリングは要求しないかわりに失敗時は内部でパニックするような関数もあります。
例えば<a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code>Index</code></a>で境界外アクセスしたときやメモリが足りずにアロケーションに失敗したとき、<a href="https://doc.rust-lang.org/std/macro.println.html#panics"><code>println!</code>が失敗したとき</a>にパニックします。
このように「失敗するとパニックする」ものはその条件をドキュメントに<code># Panics</code>という形で書いています。</li>
</ul>
</li>
</ul>
<p>(TODO: proconioの当落に応じて追記)</p>
<p>他にも、先程少し触れましたが例えば数値型の四則演算や比較を行なうときには基本的に両辺の型が等しくなければいけません。
<code>i32</code>と<code>&amp;'_ i32</code>を両辺に持って来ることくらいは許されていますが<code>i32</code>と<code>i64</code>をそのまま足したり比較したりはできません。
片方を明示的に変換する必要があります。
これは型システムの都合等ではなく数値型に対しては意図的に制限されています。</p>
<p>さらにスライスのインデックスは<a href="https://doc.rust-lang.org/stable/std/slice/trait.SliceIndex.html"><code>usize</code>及び<code>usize</code>の範囲</a>でなくてはなりません。
<code>isize</code>では駄目です。
競技プログラミングでは、非負整数として入力される値であっても、計算途中では符号付き整数の方が扱いやすいので符号付き整数として扱うことが多々あります。その場合<code>arr[(添字の計算式) as usize]</code>のように<code>usize</code>に戻す必要があります。
実際AtCoderの提出のうち、<code>&quot;as usize&quot;</code>という部分文字列を持つRustのコードは結構な数が存在します。
地味なところですが、動的計画法など添字を多用するところでは面倒に感じるかもしれません。</p>
<p>一般的には危ないのでコンパイラが許してくれないものの、使い方の制限に照らせば問題ない動作をしたいということもありえます。たとえば<a href="https://qiita.com/tanakh/items/d70561f038a0ef4f0ff1">こちら</a>では二次元配列 (<code>Vec&lt;Vec&lt;T&gt;&gt;</code>) における要素の交換を実装しようとしていますが、同じ要素に対する二つの可変参照を持てないというルールによって普通に実装することができません。競技中に「あ、これがやりたい」と思ったことが必ずしもスムーズに実装できない場合がありえます。</p>
<p>Rustで参加する競技プログラマーの中には、こうした煩雑さを改善するためのマクロやヘルパ関数 (もっと便利に標準入力がとれるようにするなど) を定義し、テンプレート (ひな型) として用意している方もいます。インターネット上で公開されている方もいらっしゃいますし、過去のコンテストでの上位Rust参加者の提出などをのぞいてみると、いろいろと参考になるかもしれません。</p>
<h4><a class="header" href="#標準ライブラリが小さい" id="標準ライブラリが小さい">標準ライブラリが小さい</a></h4>
<p>Rustは比較的新しい言語ですので、インターネット接続環境を前提にしたパッケージ管理システムCargoを標準で持ちます。このため、言語の成長とクレートやRustエコシステムの成長を分離することを目的に、Rustは標準ライブラリを最低限の抽象化とインターフェースとして位置付け、できるだけ小さく保ち続けてきました。かつて標準ライブラリの一部だったり本体にバンドルされていたライブラリ (<code>num</code>, <code>rand</code>, <code>regex</code> など) を積極的に分離することさえしています。ユーザーはCargoを使えば、使いたいパッケージを<a href="https://crates.io">crates.io</a>からいつでも自由にダウンロードできます。</p>
<p>(TODO: クレートが導入されたかどうか追記)</p>
<h4><a class="header" href="#コンパイル時間が長くなりがち" id="コンパイル時間が長くなりがち">コンパイル時間が長くなりがち</a></h4>
<p>様々な解析をコンパイル時に行う都合上、コンパイル時間が長めにかかる傾向があります。Rustではコンパイル速度を速くすることはあまり重要視されていません。特に手元で提出をテストする際、外部クレートを利用するならその外部クレートのビルドも実行することになります。二回目以降のビルドではビルドキャッシュを利用するためコンパイルする必要はありませんが、初回の実行では利用する外部クレートによっては数分単位の時間をとられる可能性があります。つまり、素早く書き上げたコードを手元で軽く実行してみることにすら時間をとられてしまい、提出時刻が数分遅れてしまうということがあり得ます。結果的に手元でコンパイルが通るかどうかをチェックする時間すら惜しいとなってしまうと本末転倒です。なお、外部ライブラリを含むパッケージをコンテスト開始前に一回ビルドしておいて、競技時はそのフォルダをコピーして編集するというふうにすれば回避できます。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo" id="todo">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-1" id="todo-1">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-2" id="todo-2">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-3" id="todo-3">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-4" id="todo-4">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-5" id="todo-5">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-6" id="todo-6">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-7" id="todo-7">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-8" id="todo-8">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-9" id="todo-9">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-10" id="todo-10">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-11" id="todo-11">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-12" id="todo-12">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-13" id="todo-13">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-14" id="todo-14">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-15" id="todo-15">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-16" id="todo-16">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#todo-17" id="todo-17">TODO</a></h1>
<p>このページは未作成です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#atcoder運営者向けの情報" id="atcoder運営者向けの情報">AtCoder運営者向けの情報</a></h1>
<p>本章では以下の内容について説明します。</p>
<ul>
<li>Rustツールチェインやクレート（外部ライブラリ）をジャッジサーバへインストールする手順</li>
<li>提出されたプログラムのコンパイルおよび実行手順</li>
</ul>
<h2><a class="header" href="#rustツールチェインやクレートの内容など" id="rustツールチェインやクレートの内容など">Rustツールチェインやクレートの内容など</a></h2>
<ul>
<li>Rust 1.39.0</li>
<li>インストールするクレート：<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/Crates-2019">このページ</a>を参照</li>
</ul>
<h2><a class="header" href="#内容についてのお問い合わせなど" id="内容についてのお問い合わせなど">内容についてのお問い合わせなど</a></h2>
<p>内容について質問などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<p>なお本章のMarkdownソースファイルはGitHub <a href="https://github.com/rust-lang-ja/atcoder-rust-resources">rust-lang-ja/atcoder-rust-resources</a>にあります。</p>
<h2><a class="header" href="#素のrust環境について" id="素のrust環境について">素のRust環境について</a></h2>
<p><a href="https://docs.google.com/spreadsheets/d/1PmsqufkF3wjKN6g1L0STS80yP4a6u-VdGiEv5uOHe0M/edit">AtCoder 2019/7 Language Updateのスプレッドシート</a>では、従来のようにクレートがインストールされていない「素のRust環境」の併設を望む声もあるようです。</p>
<p>そのような環境を望む理由については、正直な話、よくわかりません。
本章の手順に従ってセットアップした環境が問題なく動作するなら、わざわざ別の環境を用意する必要はないからです。
もしユーザプログラム（選手が提出したプログラム）がクレートを使わないなら、本章の手順でインストールしたクレートはないものと同じになります。コンパイルにかかる時間やコンパイルによって生成される実行ファイルには影響を与えません<sup class="footnote-reference"><a href="#crate-makes-no-trouble">1</a></sup>。</p>
<p>あるいは本章でセットアップした環境が何らかの条件下ではうまく動かないものであって、それに当たった際に一切コンパイルできなくなるなどの障害が起こることを心配しているのかもしれません。とはいえジャッジサーバの環境は固定されていますので、そういうことは起こりにくいと考えられます。</p>
<p>もしそれでも欲しいという声があるなら、素のRust環境を別途用意することも技術的には可能です。</p>
<div class="footnote-definition" id="crate-makes-no-trouble"><sup class="footnote-definition-label">1</sup>
<p>このことは他の言語におけるライブラリとまったく同様かと思います。例えばC++にboostがインストールされていても、それらをincludeしたり利用したりしなければコンパイル時間や成果物の性能にほぼ影響を与えないのと同じです。</p>
</div>
<h3><a class="header" href="#方法1環境は1つのままコンパイルコマンドを2種類用意する" id="方法1環境は1つのままコンパイルコマンドを2種類用意する">方法1：環境は1つのまま、コンパイルコマンドを2種類用意する</a></h3>
<p>1つ目の方法は、環境自体は本章の手順で1つだけセットアップして、コンパイルコマンドを切り替えることです。</p>
<p>本章ではクレート入りの環境を利用する方法として、公式のパッケージマネージャCargoを使う方法と、<code>rustc</code>に必要なオプションを追加して呼び出す方法の二通りを提案します。しかし、これはRustコンパイラを呼び出す方法やコンパイルオプションが違うだけであって、ツールチェインを改変するものではありません。<code>rustc</code>を今まで通りに外部クレートのパスを指定せずに呼び出せば、そのまま素の環境ということになります。</p>
<p>たとえばクレート入り環境を利用する方法として「<code>rustc</code>に必要なオプションを付ける方法」を選んだとします。このときのコンパイルコマンドは以下のように直接外部クレートのパスを指定するオプションを付けてコンパイラを実行します<sup class="footnote-reference"><a href="#dep-option-generator">2</a></sup>。</p>
<pre><code class="language-console">$ RUST_LIB=$RUST_HOME/lib
$ rustc --edition=2018 -C opt-level=3 \
    $(rustc-dep-option-generator $RUST_LIB/Cargo.toml $RUST_LIB/target/release/deps) \
    main.rs
</code></pre>
<p>この環境を素の環境、つまりクレートがインストールされていない環境と同じにするには、外部クレート関連のコンパイルオプションをつけずにコンパイラを実行します。</p>
<pre><code class="language-console">$ rustc --edition=2018 -C opt-level=3 main.rs
</code></pre>
<div class="footnote-definition" id="dep-option-generator"><sup class="footnote-definition-label">2</sup>
<p>例示のコマンドラインではクレート検索パス生成ツール（<code>rustc-dep-option-generator</code>コマンド）を利用しています。このコマンドの出力は各外部クレートのパスを指定するコンパイルオプション群です。なおこのツールを利用することは必須ではありませんし、事前にこのツールを使うか手動でコンパイルオプションを生成してベタ書きするのでも構いません。</p>
</div>
<h3><a class="header" href="#方法2文字通り2つの環境を用意する" id="方法2文字通り2つの環境を用意する">方法2：文字通り2つの環境を用意する</a></h3>
<p>2つ目の方法は、本章の環境に加えて、素のRust環境も用意することです。
シェルの環境変数<code>RUSTUP_HOME</code>と<code>CARGO_HOME</code>を本章のものとは違う値に設定して（または<code>unset</code>して）<code>rustup</code>をインストールすれば、本章の環境とは別の場所にRustツールチェインがインストールでされます。</p>
<p>コンパイルの際も環境変数の値を変えることで、本章でセットアップする環境と、素のRust環境を切り替えます。</p>
<table><thead><tr><th align="left">環境変数</th><th align="left">本章でセットアップする環境（クレートを使用できる環境）を使用する場合</th><th align="left">素のRust環境を使用する場合</th></tr></thead><tbody>
<tr><td align="left"><code>RUSTUP_HOME</code></td><td align="left"><code>/usr/local/lib/rust/rustup</code></td><td align="left"><code>rustup</code>をデフォルトの場所にインストールしたのなら<code>unset RUSTUP_HOME</code></td></tr>
<tr><td align="left"><code>CARGO_HOME</code></td><td align="left"><code>/usr/local/lib/rust/cargo</code></td><td align="left">Cargoをデフォルトの場所にインストールしたのなら<code>unset CARGO_HOME</code></td></tr>
</tbody></table>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#本章で想定している環境" id="本章で想定している環境">本章で想定している環境</a></h1>
<h2><a class="header" href="#用語" id="用語">用語</a></h2>
<p>まずは用語を整理します。本章で用いる用語には以下のものがあります。</p>
<ul>
<li><strong>ユーザプログラム</strong>
<ul>
<li>選手が提出したプログラムのこと</li>
</ul>
</li>
<li><strong>ジャッジサーバ</strong>
<ul>
<li>オンラインジャッジを行うサーバのこと。ジャッジサーバはユーザプログラムをコンパイルし、実行する</li>
</ul>
</li>
<li><strong>実行ファイル</strong>（executable file）
<ul>
<li>マシンコードを含み、メモリに読み込んで実行できる形式のファイルのこと。バイナリファイルとも呼ばれる。プログラムのソースコードをコンパイル、リンクすることで生成される</li>
</ul>
</li>
<li><strong>Rustコンパイラ</strong>（<code>rustc</code>）
<ul>
<li><code>rustc</code>コマンドのこと。Rustプログラムのコンパイルとリンクを行う</li>
<li>なお<code>rustc</code>にはリンカの機能は含まれていないため、<code>rustc</code>はリンク時に外部ツールを呼び出すようになっている。ターゲットがLinux Gnu ABIの場合は<code>gcc</code>経由で<code>ld</code>を呼び出す</li>
</ul>
</li>
<li><strong>Cargo</strong>（<code>cargo</code>）
<ul>
<li>Rustのビルドツール兼パッケージマネージャの<code>cargo</code>コマンドのこと</li>
<li>なおカーゴは貨車の意味</li>
</ul>
</li>
<li><strong>Rustツールチェイン</strong>
<ul>
<li>Rustコンパイラ、Cargo、Rustの標準ライブラリなどをバージョンごとにまとめたもの</li>
</ul>
</li>
<li><strong>Rustup</strong>（<code>rustup</code>）
<ul>
<li>Rustツールチェインの管理ツールである<code>rustup</code>コマンドのこと</li>
<li>指定したバージョンのRustツールチェインを簡単にインストールできるだけでなく、複数バージョンのツールチェインも管理できる</li>
<li><code>rustc</code>やCargoと同様、Rustプロジェクトチームにより公式にサポートされている</li>
</ul>
</li>
<li><strong>クレート（crate）</strong>
<ul>
<li>クレートは貨物などを入れる木箱の意味</li>
<li>Rustにはlib crateとbin crateがある</li>
<li>ライブラリクレート（lib crate）はRustで書かれたライブラリのこと。コンパイルするとrlibファイルが作られる</li>
<li>バイナリクレート（bin crate）はRustで書かれたアプリケーションのこと。コンパイル、リンクすると実行ファイルが作られる</li>
<li>世界中のRustユーザが作成した無数のクレートが、セントラルリポジトリの<a href="https://crates.io">crates.io</a>で公開されている</li>
<li>一般にクレートと呼ぶ場合は文脈によりバイナリクレートかライブラリクレートかを区別する</li>
<li>今回の例では、外部クレートは全てlib crateで、外部クレートをまとめてコンパイルするため・ユーザープログラムをコンパイルするために使うクレートはbin crate</li>
</ul>
</li>
<li><strong>Cargoパッケージ</strong>
<ul>
<li>Cargoの1単位。Rustのソースコードや<code>Cargo.toml</code>などの設定ファイルで構成される</li>
<li>1つのCargoパッケージには単一または複数のクレートが含まれる</li>
</ul>
</li>
<li><strong>Cargoプロジェクト</strong>
<ul>
<li>基本的にCargoパッケージと同じもの</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#想定する環境" id="想定する環境">想定する環境</a></h2>
<p>本章ではAtCoderのジャッジサーバ環境として、以下のものを想定しています。</p>
<ul>
<li>Ubuntu 18.04 LTS x86_64</li>
<li>ユーザプログラムは何らかのコンテナ内で実行される
<ul>
<li>インターネットなどのネットワークアクセスは不可</li>
<li>物理メモリ、ディスクファイルサイズ、プロセス数などの制限がある</li>
<li>ユーザプログラムが出力したファイルは、テストケースを1つ実行するごとに削除される</li>
</ul>
</li>
<li>プログラミング言語ごとにファイルシステムが分かれているわけではない
<ul>
<li>たとえば提出言語としてBashやPythonを選択したときに、他の言語のコンパイラを実行するようなスクリプトを提出、実行できる</li>
<li>（このようなプログラムを提出することは推奨はされないだろうが、現状は可能となっている）</li>
</ul>
</li>
<li>ユーザプログラムをコンパイル、実行するLinuxユーザは、単一のユーザなのか、複数のユーザなのかは不明</li>
</ul>
<h2><a class="header" href="#一般的なrustプログラム開発環境との違い" id="一般的なrustプログラム開発環境との違い">一般的なRustプログラム開発環境との違い</a></h2>
<p>一般的なRustプログラムの開発では<code>rustup</code>をデフォルト設定で使うことで、いまログインしているLinuxユーザ専用の場所にツールチェインをインストールします。またユーザプログラムのビルドにはCargoを使い、そのプログラムが依存しているクレートのソースファイルを自動的にダウンロードし、ユーザプログラムと共にコンパイルします。</p>
<p>ジャッジサーバではこの方法はあまりうまくいきません。</p>
<ul>
<li>Linuxユーザを複数使用している場合に、ユーザごとにツールチェインをインストールすることになる。</li>
<li>ツールチェインのファイルパーミッションがそのままだと、悪意のあるユーザプログラムがツールチェインを改変してしまうかもしれない。</li>
<li>クレートのソースファイルのダウンロードをCargoに任せると
<ul>
<li>ダウンロードに時間と回線負荷がかかる。</li>
<li>crates.ioの障害の際や依存クレートのいずれかが取り消された際などにダウンロードできずエラーとなる可能性がある。</li>
<li>不正防止のためにユーザプログラムの実行時にネットワークを制限する場合、ビルドと実行の間でネットワークから切断する処理を挿入する必要がある。</li>
</ul>
</li>
<li>ジャッジの際に毎回クレートがコンパイルされることになり非効率。
<ul>
<li>マシンスペックにもよりますが、手元の環境 (i5-8250U) では <strong>CPU全コア100%で並列実行して分単位の時間</strong> がかかります。</li>
</ul>
</li>
</ul>
<p>そこで本章では以下のようにします。</p>
<ul>
<li>Rustツールチェインを、ジャッジサーバ上の全Linuxユーザがread-onlyでアクセスできる場所にインストールする。</li>
<li>選手が使用できるクレートを事前に選定し、それらを全て設定したプロジェクトをコンパイルしておく。
<ul>
<li>コンパイルしたプロジェクトはジャッジサーバ上の全Linuxユーザがread-onlyでアクセスできる場所に保存する。</li>
</ul>
</li>
<li>ユーザプログラムをコンパイルする際は以下のいずれかの方法をとる。
<ul>
<li>事前にコンパイルしたCargoプロジェクトをコピーした上で<code>main.rs</code>をユーザプログラムに置き換えてCargoを用いる。</li>
<li>所定のオプションを簡単なツールにより生成して<code>rustc</code>を直接実行する。</li>
</ul>
</li>
</ul>
<p>最後のユーザプログラムのコンパイルについて二つの方法<sup class="footnote-reference"><a href="#good-is-bad-each-other">1</a></sup>がありますが、それぞれについて補足します。</p>
<div class="footnote-definition" id="good-is-bad-each-other"><sup class="footnote-definition-label">1</sup>
<p>これらはお互いに「他方の短所を解決するかわりに他方の長所を持たない」という関係があります。</p>
</div>
<h3><a class="header" href="#cargoを用いる場合" id="cargoを用いる場合">Cargoを用いる場合</a></h3>
<p>通常のRustプロジェクトと同様ですが、通常なら意識する必要のない「インターネットからの依存クレートの自動ダウンロード」と「依存クレートの自動再コンパイル」を避ける必要があります。自動ダウンロードを避けるには<code>--offline</code>オプションをつける必要があります<sup class="footnote-reference"><a href="#offline-option">2</a></sup>。依存クレートの自動再コンパイルを正式に抑制する方法はありません。ただし、ツールチェインもクレートもバージョンアップしない固定された環境ではまず起きないだろうとは思われます<sup class="footnote-reference"><a href="#prevent-auto-recompile">3</a></sup>。</p>
<div class="footnote-definition" id="offline-option"><sup class="footnote-definition-label">2</sup>
<p>これはRust 1.36から導入された、ネット接続環境のない場合でもローカルキャッシュを活用してできるだけコンパイル不能になることを避けるオプションです。詳しくは<a href="atcoder-env/ncameron.org/blog/cargo-offline/">こちら</a>もご参照ください。</p>
</div>
<div class="footnote-definition" id="prevent-auto-recompile"><sup class="footnote-definition-label">3</sup>
<p>これはCargoのソースを見たわけ <strong>ではなく</strong> 、多少試したところは大丈夫そうだという推測でしかありませんし、仮に今は大丈夫でも将来的に変更が加わる可能性もあります。</p>
</div>
<p>考えられる長所と短所を述べますが、要約すると、長所は公式であることです。逆に短所はディレクトリ構成が縛られること、想定されていない環境下でも確実に動作するのか分からないことです。</p>
<h4><a class="header" href="#長所" id="長所">長所</a></h4>
<ul>
<li>公式のツールなので他の準備が不要。</li>
<li>公式のツールなのでバグにも見舞われにくく、処理の信頼性が高い。</li>
</ul>
<h4><a class="header" href="#短所" id="短所">短所</a></h4>
<ul>
<li>全部入りのCargoプロジェクト全体をコピーして実行環境に展開する必要がある。
<ol>
<li>所定のディレクトリ構成にしなければならないためです。
<ul>
<li><code>Cargo.toml</code>があり、<code>src</code>ディレクトリがあり、...。</li>
</ul>
</li>
<li><code>target</code>ディレクトリ以下に生成されている依存クレートのコンパイルキャッシュを利用するためです。
<ul>
<li>Cargoを動作させる <strong>だけ</strong> であれば<code>Cargo.toml</code>をコピーして<code>src</code>に<code>main.rs</code>を入れるだけOKです。問題なくコンパイル・実行できます。ただしそれでは依存クレートを含めてゼロからコンパイルしますので、マシンパワーにもよりますが通常 <strong>並列処理の高負荷と分単位の時間</strong> がかかります。従って既に一度ビルドされたプロジェクトを丸ごとコピーしてくる必要があります。</li>
<li>(参考) この<code>target</code>ディレクトリのサイズは手元環境では163MBでした。コンパイルの度にこれだけのディレクトリをコピーする必要があります。</li>
</ul>
</li>
<li>実行環境の改竄から守るためです。
<ul>
<li>もしCargoプロジェクトを使い回すことにすると、例えば次のようなことが可能になります。
<ul>
<li>一回目の実行で、ライブラリを差し替える、または、必要なファイルに偽装して計算結果を保存し、二回目の実行で不正な動作をさせる。</li>
<li><code>.cargo/config</code>ファイルに設定を追加する(例:コンパイルオプションを変更するなど)。</li>
</ul>
</li>
<li>プロジェクトに属するファイル・ディレクトリを読取専用にすれば緩和されると思いますが、この場合<code>cargo</code>自体が処理の途中に何らかの形で書き込みを行う(ログやキャッシュなど)ことがあれば正常に動作しない可能性がゼロではありません。</li>
</ul>
</li>
</ol>
</li>
<li>依然としていつ依存クレートの再コンパイルが行なわれるかについて保証を得られない。
<ul>
<li>再コンパイルが起こると通常 <strong>並列処理の高負荷と分単位の時間</strong> がかかります。</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#rustcを直接実行する場合" id="rustcを直接実行する場合">rustcを直接実行する場合</a></h3>
<p>Cargoは高機能ですが、実際のコンパイル処理は適切なオプションをつけて<code>rustc</code>を呼び出しているにすぎません。Cargoと同じコンパイルオプションを生成することができればCargoに頼らなくても実行ファイルを生成できます。要するに、現在のRustと同様に単体ファイルを<code>rustc</code>でコンパイルする形ですが、外部クレートのパスなどを指定するコンパイルオプションを追加するということです<sup class="footnote-reference"><a href="#adding-library-path-options">4</a></sup>。</p>
<div class="footnote-definition" id="adding-library-path-options"><sup class="footnote-definition-label">4</sup>
<p>イメージとしては<code>gcc</code>等でいう<code>-lsome_library</code>のようなものになります。</p>
</div>
<p>考えられる長所と短所を述べますが、要約すると、長所はCargoを用いる場合の短所が解決されていることです。逆に短所は公式ではないことで、Cargoを使っていれば起きないような齟齬が起きる可能性があることです。</p>
<h4><a class="header" href="#長所-1" id="長所-1">長所</a></h4>
<ul>
<li>具体的に<code>rustc</code>を呼び出すため、実際に為される処理が明確にコンパイルとリンクのみであり、Cargoのようにブラックボックスではない。
<ul>
<li>依存クレートの自動ダウンロードも自動再コンパイルも<code>rustc</code>の機能ではないので大丈夫です。</li>
</ul>
</li>
<li>ディレクトリ構成を気にする必要はない。
<ul>
<li>今まで通り、適当なディレクトリにユーザプログラムを好きな名前で配置するだけでOKです。</li>
</ul>
</li>
<li>全部入りのCargoプロジェクトをコピーする必要はない。
<ul>
<li>read-onlyのシステム領域に依存関係のコンパイル済みクレートを用意しておけば、参照する依存クレートのパスとしてその場所を指定するだけで事足ります。</li>
</ul>
</li>
<li>依存クレートを読み取り専用にすることができる。
<ul>
<li>Cargoの場合は再コンパイルにより依存クレートのファイルを更新する可能性があるためread-onlyとしたときにどう動作するか確信できませんが、<code>rustc</code>を直接実行する場合は依存クレートのファイルを参照するだけですので、read-onlyでも問題ないと思われます。</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#短所-1" id="短所-1">短所</a></h4>
<ul>
<li>
<p>コンパイルオプションを準備する必要がある。</p>
<ul>
<li>手でやる場合は<code>cargo build --release -v</code>の出力を参考にして必要なオプションを選ぶ必要があります。</li>
<li>コンパイルオプションを生成するためのツールを作成しましたので、それを利用することもできます。このツールを利用する場合はそのツールのコンパイルと実行が必要です<sup class="footnote-reference"><a href="#tool-compilation">5</a></sup>。</li>
</ul>
</li>
<li>
<p>オプションが正しいかどうか、欠けていないかどうかを気にする必要がある。</p>
<ul>
<li>普通は<code>cargo build</code>で全て終わるため<code>rustc</code>を直接実行することはなく、どのクレートにも手動でリンクする場合のオプションに関する情報はありません。</li>
<li>ただし一度テストして問題がなかったのなら、固定されている環境で後々問題を起こすことは考えづらいです。</li>
</ul>
</li>
<div class="footnote-definition" id="tool-compilation"><sup class="footnote-definition-label">5</sup>
<p>とはいえツールはRustで書かれているため<code>git clone</code>と<code>cargo build</code>程度です。</p>
</div>
</ul>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#インストール" id="インストール">インストール</a></h1>
<p>本節では以下の内容について説明します。</p>
<ul>
<li>Rustツールチェインのインストール</li>
<li>クレートのコンパイルとインストール</li>
<li>(必要なら) クレートの検索パス生成ツールのインストール</li>
</ul>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#rustツールチェインのインストール" id="rustツールチェインのインストール">Rustツールチェインのインストール</a></h1>
<p>このページではAtCoderのジャッジサーバにRustツールチェインをインストールする手順を説明します。</p>
<h2><a class="header" href="#rustバージョン" id="rustバージョン">Rustバージョン</a></h2>
<p>今回の言語アップデートでは2019年11月7日にリリースされた1.39.0をインストールします。</p>
<p>Rustの安定版（stable版）は6週間ごとにリリースされますので、既にバージョン1.40.0が12月19日にリリースされています。ただ、安定性のためには世に出てからある程度の時間が経っているバージョンを選ぶ方が望ましいと考えられますので、ここでは1つ前のバージョンをインストールします。様子を見る期間については、現在のところはおよそ次期バージョンがリリースされるまでを1つの目安としています。</p>
<p>ツールチェインのインストールには<code>rustup</code>というRustプロジェクト公式のコマンドラインツールを使います。
これにより特定のバージョンのRustをインストールすることが可能になります。</p>
<h2><a class="header" href="#ツールチェインの内容とインストール先" id="ツールチェインの内容とインストール先">ツールチェインの内容とインストール先</a></h2>
<p>今回インストールするRustツールチェインには以下のものが含まれています。</p>
<ul>
<li>Rustコンパイラである<code>rustc</code>コマンド</li>
<li>Rustのビルドツール兼パッケージマネージャである<code>cargo</code>コマンド</li>
<li>Rustの標準ライブラリとAPIドキュメント</li>
</ul>
<p>実際のコンパイルにもCargoを利用する場合はもちろんですが、運用時には<code>rustc</code>に必要なオプションを付けてコンパイルする方法をとる場合でも、依存ライブラリをまとめてコンパイルするためにCargoを利用します。具体的にはこのページに続く数ページをご覧ください。</p>
<p>Rustツールチェインはデフォルトでは<code>rustup</code>を実行したLinuxユーザのホームディレクトリ配下（<code>~/.rustup/toolchains</code>）にインストールされます。
しかし今回はジャッジサーバ上の全てのLinuxユーザから使えるよう、<code>/usr/local/lib/rust</code>配下にインストールします。
このディレクトリは一般のLinuxユーザからは書き込みができないように設定し、ジャッジの際にツールチェインがユーザプログラムによって変更されないよう保護します。</p>
<h2><a class="header" href="#依存ソフトウェアのインストール" id="依存ソフトウェアのインストール">依存ソフトウェアのインストール</a></h2>
<p>Rustツールチェインをインストールする前に、Rustプログラムのリンクやクレートのビルドに必要なソフトウェアをインストールしましょう。
必要なソフトウェアは以下のとおりです。</p>
<ul>
<li>Rustツールチェインやクレートのダウンロードに必要なツール：curl, git-core</li>
<li>ユーザプログラムのリンク時に必要なツール：gcc, binutils</li>
<li>一部のRustクレートのビルドに必要なツール：make, pkg-config</li>
</ul>
<p>以下のコマンドを実行します。</p>
<pre><code class="language-console">$ sudo apt update
$ sudo apt install -y curl git-core gcc binutils make pkg-config
</code></pre>
<h2><a class="header" href="#rustツールチェインのインストール-1" id="rustツールチェインのインストール-1">Rustツールチェインのインストール</a></h2>
<p><code>rustup</code>とRustツールチェインをインストールしましょう。
以下のコマンドを実行します。</p>
<pre><code class="language-console">$ sudo -i

# whoami
root

# RUST_TOOLCHAIN=1.39.0
# export RUST_HOME=/usr/local/lib/rust
# export RUSTUP_HOME=${RUST_HOME}/rustup
# export CARGO_HOME=${RUST_HOME}/cargo

# mkdir -p $RUST_HOME
# chmod 0755 $RUST_HOME

## rustupをインストールし、同時に指定したバージョンのRustツールチェインをインストールする
# curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | \
    sh -s -- -y --default-toolchain &quot;${RUST_TOOLCHAIN}&quot; --no-modify-path
</code></pre>
<p>インストールに成功すると以下のように表示されます。</p>
<pre><code class="language-console">info: downloading installer
info: syncing channel updates for '1.39.0-x86_64-unknown-linux-gnu'
info: latest update on 2019-11-07, rust version 1.39.0 (4560ea788 2019-11-04)
info: downloading component 'rustc'
info: downloading component 'rust-std'
info: downloading component 'cargo'
...（中略）...

  1.39.0 installed - rustc 1.39.0 (4560ea788 2019-11-04)


Rust is installed now. Great!

To get started you need Cargo's bin directory (/usr/local/lib/rust/cargo/bin)
in your PATH environment variable.

To configure your current shell run source /usr/local/lib/rust/cargo/env
</code></pre>
<h2><a class="header" href="#環境変数の設定" id="環境変数の設定">環境変数の設定</a></h2>
<p>rootユーザと一般のLinuxユーザがRustツールチェインを使えるように設定しましょう。
それぞれのユーザのシェルの初期設定ファイルに以下のコマンドを追加します。
（<code>bash</code>の例です）</p>
<pre><code class="language-bash"># .bashrcファイルに以下のコマンドを追加する
export RUST_HOME=/usr/local/lib/rust
export RUSTUP_HOME=${RUST_HOME}/rustup
export CARGO_HOME=${RUST_HOME}/cargo
source ${CARGO_HOME}/env
</code></pre>
<p>最後の<code>source</code>コマンドは、コマンド検索パス（<code>PATH</code>）に<code>/usr/local/lib/rust/cargo/bin</code>を追加します。</p>
<h2><a class="header" href="#インストール後の動作確認" id="インストール後の動作確認">インストール後の動作確認</a></h2>
<p>Rustツールチェインが正しくインストールできたか確認しましょう。
一般のLinuxユーザで以下のコマンドを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行

$ source ~/.bashrc

$ echo $RUSTUP_HOME
/usr/local/lib/rust/rustup

$ which rustc
/usr/local/lib/rust/cargo/bin/rustc

## バージョンなどを確認
$ rustc -V
rustc 1.39.0 (4560ea788 2019-11-04)

$ cargo -V
cargo 1.39.0 (1c6ec66d5 2019-09-30)

$ rustup -V
rustup 1.21.1 (7832b2ebe 2019-12-20)

$ rustup show
Default host: x86_64-unknown-linux-gnu

1.39.0-x86_64-unknown-linux-gnu (default)
rustc 1.39.0 (4560ea788 2019-11-04)

## Rustプログラムのビルドと実行ができることを確認
$ cd /tmp
$ cargo new hello &amp;&amp; cd $_
$ cargo run
Hello, world!   # このように表示されればOK

$ cd
$ rm -rf /tmp/hello
</code></pre>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#クレートのコンパイルとインストール" id="クレートのコンパイルとインストール">クレートのコンパイルとインストール</a></h1>
<p>このページではAtCoderのジャッジサーバにRustの外部ライブラリであるクレートをインストールする手順を説明します。</p>
<h2><a class="header" href="#インストールするクレートについて" id="インストールするクレートについて">インストールするクレートについて</a></h2>
<p>今回インストールするクレートは、SlackのRust日本語コミュニティ「rust-jp」のメンバーがAtCoderでぜひ使いたいと考えているものです。
大半は既存のクレートですが、この機会に新たに開発したものもあります。</p>
<p>これらのクレートは主に以下の種類に分類されます。</p>
<ul>
<li>Rust の標準ライブラリにないが、他のいくつかの言語では標準の機能であって、かつ競プロ以外でも広く使われているもの
<ul>
<li>例：C++の<code>lower_bound</code>や<code>bitset</code>に相当する機能</li>
</ul>
</li>
<li>競技プログラミング特化型だが、競プロの面白さを損なわない範囲（ズルにならない範囲）で便利になるもの
<ul>
<li>例：Rustでは入力関連の記述が煩雑になりがちなので、それらを簡潔に記述できるマクロ集</li>
</ul>
</li>
<li>セキュリティなどの理由から高速性が犠牲になっている機能を置き換え、特にマラソンにおいて威力を発揮するもの
<ul>
<li>例：標準ライブラリのハッシュ関数はDoS攻撃を避けるために暗号強度があり、計算量が多い。
競技プログラミングでは暗号強度は求められず、より計算量の少ないハッシュ関数で十分</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#atcoder運営者様へのお願い" id="atcoder運営者様へのお願い">AtCoder運営者様へのお願い</a></h3>
<p>対象クレートの一覧は<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/wiki/Crates-2019">このページ</a>にあります。
ジャッジサーバで使用して問題ない内容か、インストール前にレビューをお願いいたします。</p>
<p>質問や要望などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<h2><a class="header" href="#ファイルレイアウトとクレートの事前コンパイル" id="ファイルレイアウトとクレートの事前コンパイル">ファイルレイアウトとクレートの事前コンパイル</a></h2>
<p>インストール作業に入る前に、背景を説明します。
一般的なCargoを使用した開発では、<code>Cargo.toml</code>という設定ファイルに依存クレートの情報を記述します。
<code>cargo build</code>コマンドを実行すると、Cargoはそれらのクレートのソースコードをダウンロードし、適切なオプションと共に<code>rustc</code>を実行することでクレートをコンパイルします。
クレートのソースコードは<code>$CARGO_HOME/registory/src</code>にダウンロードされ、コンパイル済みのクレート（<code>rlib</code>ファイル）は<code>Cargo.toml</code>が置かれたディレクトリを起点とする相対ディレクトリ<code>./target/release/deps</code>配下に出力されます。</p>
<h3><a class="header" href="#一般的な開発時のファイルレイアウト" id="一般的な開発時のファイルレイアウト">一般的な開発時のファイルレイアウト</a></h3>
<pre><code class="language-console">$HOME   # ユーザのホームディレクトリ
|-- $CARGO_HOME (~/.cargo)
|   └-- registory
|       └-- src
|           └-- クレートのソースコード
|
└-- my-package
    |-- Cargo.toml    # 設定ファイル。依存クレートの情報が書かれている
    |-- src
    |   └-- main.rs   # Rustプログラムのソースコード
    └-- target
        └-- release
            |-- deps
            |   |-- X.rlib  # コンパイル済みのクレート
            |   └-- Y.rlib
            └-- main        # コンパイル、リンク済みの実行ファイル
</code></pre>
<p>ジャッジサーバーでは様々な条件が通常の環境と異なるため、<a href="atcoder-env/./supported-environment.html#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AArust%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84">最初に説明した通り</a>いくつか工夫をする必要があります。</p>
<p>まず、今回は各ファイルを以下のように配置し、クレートのコンパイルは導入時に済ませておくことにします。</p>
<h3><a class="header" href="#atcoderジャッジサーバでのファイルレイアウト導入時に配置するもの" id="atcoderジャッジサーバでのファイルレイアウト導入時に配置するもの">AtCoderジャッジサーバでのファイルレイアウト（導入時に配置するもの）</a></h3>
<pre><code class="language-console">$RUST_HOME (/usr/local/lib/rust)
|-- $CARGO_HOME (/usr/local/lib/rust/cargo)
|   └-- registory
|       └-- src
|           └-- クレートのソースコード
└-- lib
    |-- Cargo.toml          # 設定ファイル。依存クレートの情報が書かれている
    └-- target
        └-- release
            └-- deps
                |-- X.rlib  # コンパイル済みのクレート
                └-- Y.rlib
</code></pre>
<p>そしてジャッジの際には<a href="atcoder-env/./supported-environment.html#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AArust%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84">以前説明した</a>Cargoを利用する方法と<code>rustc</code>を利用する方法のいずれかを利用してコンパイルします。</p>
<h3><a class="header" href="#cargo-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの" id="cargo-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの">[cargo] AtCoderジャッジサーバでのファイルレイアウト（ジャッジの際に作成するもの）</a></h3>
<pre><code class="language-console">$HOME                      # ユーザのホームディレクトリ
└-- WORKAREA               # ジャッジ用の一時ディレクトリ
    └-- lib                # 全部入りプロジェクトをまるまるコピーしたもの
        |-- main.rs        # ユーザプログラム（提出されたプログラム）のソースコードに置き換える
        |-- Cargo.toml
        └-- target
            └-- release
                |-- deps   # (外部クレートのコンパイルキャッシュ)
                └-- atcoder-rust-base # コンパイル、リンク済みの実行ファイル
</code></pre>
<h3><a class="header" href="#rustc-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの" id="rustc-atcoderジャッジサーバでのファイルレイアウトジャッジの際に作成するもの">[rustc] AtCoderジャッジサーバでのファイルレイアウト（ジャッジの際に作成するもの）</a></h3>
<p>Cargoを使用せず、<code>rustc</code>に適切なオプション（ライブラリ検索パスなど）を与えて実行することで、事前にコンパイルしておいた<code>rlib</code>ファイルとリンクさせます。</p>
<pre><code class="language-console">$HOME             # ユーザのホームディレクトリ
└-- WORKAREA      # ジャッジ用の一時ディレクトリ
    |-- main.rs   # ユーザプログラム（提出されたプログラム）のソースコード
    └-- main      # コンパイル、リンク済みの実行ファイル
</code></pre>
<h2><a class="header" href="#クレートのコンパイルに使用するcargoパッケージのダウンロード" id="クレートのコンパイルに使用するcargoパッケージのダウンロード">クレートのコンパイルに使用するCargoパッケージのダウンロード</a></h2>
<p>それではインストール作業に入りましょう。実際のコンパイルにCargoを使う場合も<code>rustc</code>を使う場合もここは同様です。
クレートの事前コンパイルに使用するCargoパッケージは、GitHub <a href="https://github.com/rust-lang-ja/atcoder-rust-base/tree/ja-all-enabled">rust-lang-ja/atcoder-rust-base（ja-all-enabledブランチ）</a>に用意されています。
このパッケージには<code>Cargo.toml</code>ファイルなどが含まれており、インストール対象のクレートがすでに設定されています。
（<code>[dependencies]</code>セクションに書かれています）</p>
<p>このリポジトリを<code>git clone</code>し、<code>/usr/local/lib/rust/lib</code>に配置します。以下のコマンドを実行します。</p>
<pre><code class="language-console">## rootユーザで作業する
$ sudo -i
# whoami
root

# echo $RUST_HOME
/usr/local/lib/rust

## Cargoパッケージをgit cloneする
# git clone https://github.com/rust-lang-ja/atcoder-rust-base.git \
    --branch ja-all-enabled --single-branch \
    ${RUST_HOME}/lib
</code></pre>
<h2><a class="header" href="#クレートを削除する" id="クレートを削除する">クレートを削除する</a></h2>
<p>検討の結果、一部のクレートは残念ながら導入すべきでないクレートだと判断されることもあるかと思います。そういった場合は<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>を通してご連絡頂ければ当該クレートとそれに関連するテストの削除等の対応をさせていただきますが、一応、その方法も説明しておこうと思います。</p>
<p>例えば、競プロ入出力補助の<code>proconio</code>が相応しくないので削除したいとなったとします。まずはこのクレートを依存から削除する必要があります。<code>git clone</code>したディレクトリ内の<code>Cargo.toml</code>ファイルを開き、<code>[dependencies]</code>セクションを見つけてください。すると例えば次のようにクレートが並んでいるかと思います。</p>
<pre><code class="language-toml">[dependencies]
# AtCoder 2019年言語アップデート以降に使用できるクレート

# 競技プログラミングの入出力サポート
proconio = { version = &quot;=0.3.4&quot;, features = [&quot;derive&quot;] }

# f64のOrd/Eq実装
ordered-float = &quot;=1.0.2&quot;

(...以下略...)
</code></pre>
<p>クレートによってオプションが付せられていることもありますが、<code>{削除したいクレート名} = ...</code>となっている行をコメントアウトまたは削除してください。</p>
<p>続いてテストを削除します。<code>src/main.rs</code>ファイルを開くと、ずらっとテスト関数が並んでいます。これらの関数から<code>run_{削除したいクレート名}</code>と<code>test_{削除したいクレート名}</code>という関数を丸ごと削除してください。<code>test_{削除したいクレート名}</code>関数は、その前の行に<code>#[test]</code>アトリビュートがついているかと思いますので、それごと削除してください。</p>
<p>そして<code>main()</code>関数内にある<code>run_{削除したいクレート名}</code>関数を呼び出す文を削除してください。</p>
<p>基本的にはこれで削除は完了です。この後クレートのテストを行いますが、ここで<code>unresolved import</code>系のエラーが出るようなら適宜削除してください。</p>
<p>削除するべきコードが無い場合、テストが別のファイルに分かれている場合があります。例えば<code>jemallocator</code>系を削除したいならば<code>tests/test_jemallocator.rs</code>というファイルを削除してください。</p>
<p>また<code>jemallocator</code>系を削除する場合、<code>Cargo.toml</code>内の以下の部分も削除してください。</p>
<pre><code class="language-toml">[features]
jemalloc = [&quot;jemalloc-ctl&quot;, &quot;jemallocator&quot;]
default = [&quot;jemalloc&quot;]
</code></pre>
<pre><code class="language-toml"># 代替ヒープアロケータ。条件によってはシステムアロケータより速いことも
[target.'cfg(not(windows))'.dependencies]
jemallocator = { version = &quot;=0.3.2&quot;, optional = true }
jemalloc-ctl = { version = &quot;=0.3.3&quot;, optional = true }
</code></pre>
<pre><code class="language-toml">[[test]]
name = &quot;jemallocator&quot;
path = &quot;tests/test_jemallocator.rs&quot;
required-features = [&quot;jemalloc&quot;]
</code></pre>
<h2><a class="header" href="#クレートのテスト" id="クレートのテスト">クレートのテスト</a></h2>
<p>一度、導入したクレートが正しく動作するのかを確認しましょう。</p>
<p>テストコードは<code>$RUST_HOME/lib/src/</code>及び<code>$RUST_HOME/lib/tests</code>にあります。先に述べたように使わないクレートに関わるコードは削除してください。実行するには、<code>cargo test</code>コマンドを入力します。</p>
<pre><code class="language-console"># cd $RUST_HOME/lib
$ cargo test --release
   Compiling atcoder-rust-base v0.1.0 (...)
    Finished release [optimized] target(s) in 7.31s
     Running target\release\deps\...

running 11 tests
test test_ascii ... okYes
Yes

test test_bitset_fixed ... ok
test test_modtype ... ok
test test_ordered_float ... ok
test test_permutohedron ... ok
test test_itertools ... ok
test test_rand_family ... ok
test test_proconio ... ok
test test_regex ... ok
test test_rustc_hash ... ok
test test_superslice ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>多少表示されるテストの個数は異なるかもしれませんが、一番下の行が<code>test result: ok.</code>で<code>0 failed;</code>となっていれば問題ありません。</p>
<p>また今回、使用するクレート自体のテストを実行するためのツール、<code>dep-tests</code>を作成しました。
<code>dep-tests</code>はcargo commandのエイリアスとして、<code>cargo dep-tests</code>で起動できます。
ただし<code>alias</code>は任意のスクリプトを実行できないのでcwdが<code>$RUST_HOME/lib</code>である必要があります。
以下、cwdを<code>$RUST_HOME/lib</code>とします。</p>
<p>参考: <a href="https://qiita.com/ubnt_intrepid/items/9600fd734e6d116bc9cb">cargo で npm-scripts 的なことをする</a></p>
<pre><code class="language-toml">[alias]
dep-tests = [&quot;run&quot;, &quot;--manifest-path&quot;, &quot;./dep-tests/Cargo.toml&quot;, &quot;--&quot;]
</code></pre>
<pre><code class="language-console">$ cargo dep-tests --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `dep-tests/target/debug/dep-tests --help`
dep-tests 0.0.0
Run all of the tests in the dependency graph.

USAGE:
    dep-tests [FLAGS] [OPTIONS] &lt;dir&gt;

FLAGS:
        --all-features           Activate all available features
        --no-default-features    Do not activate the `default` feature
        --frozen                 Require Cargo.lock and cache are up to date
        --locked                 Require Cargo.lock is up to date
        --offline                Run without accessing the network
    -h, --help                   Prints help information
    -V, --version                Prints version information

OPTIONS:
    -p, --package &lt;SPEC&gt;...         Package to run test for
        --features &lt;FEATURES&gt;...    Space-separated list of features to activate
        --color &lt;WHEN&gt;              Coloring: auto, always, never
    -d, --depth &lt;N&gt;                 How deep in the dependency chain to search

ARGS:
    &lt;dir&gt;    Directory to run tests [default: /tmp/atcoder-rust-base-dep-tests]
</code></pre>
<pre><code class="language-console">$ cargo dep-tests --all-features -d 1
</code></pre>
<p>いくつかのクレートは<code>dep-tests</code>で動かないのでテストしないように除外されています。
そのリストと理由は<code>$RUST_HOME/lib/dep-tests.toml</code>に記述されています。</p>
<p><code>dep-tests</code>の動作の説明をしておきます。</p>
<p>実は<code>cargo</code>にはdependency graph上にあるクレートのテストをそのまま実行する機能があります。</p>
<pre><code class="language-console">$ cargo test -p maplit -p num
</code></pre>
<p>しかしこれには致命的な欠点があり、<a href="https://github.com/rust-lang/cargo/blob/0.40.0/src/cargo/ops/cargo_compile.rs#L346-L355"><code>[dev-dependencies]</code>が一つでもあると問答無用で</a>拒否されます。</p>
<pre><code class="language-console">$ cargo test -p regex
error: package `regex` cannot be tested because it requires dev-dependencies and is not a member of the workspace
</code></pre>
<p>このエラーは<a href="https://github.com/rust-lang/cargo/pull/6192"><code>rust-lang/cargo#6192</code></a>で追加されました。
禁止されている理由はこのPRで言及されている通り、dev-dependencyがある場合ワースクペース上には無い新たなクレートが必要になることがあるためです。
<code>dep-tests</code>は『拡張』したワークスペースを新たに作成してその上でテストを実行します。</p>
<p>例えば<code>itertools v0.8.1</code>, <code>regex v1.3.1</code>を対象にした場合、以下のような<code>Cargo.toml</code>が生成されます。</p>
<pre><code class="language-toml">[package]
name = &quot;atcoder-rust-base-dep-tests&quot;
version = &quot;0.0.0&quot;
edition = &quot;2018&quot;
publish = false

[workspace]
members = [&quot;./itertools-0.8.1&quot;, &quot;./regex-1.3.1&quot;]

[patch.crates-io]
itertools = {path = &quot;./itertools-0.8.1&quot;}
regex = {path = &quot;./regex-1.3.1&quot;}

[dependencies]
_0 = {package = &quot;aho-corasick&quot;,version = &quot;=0.7.6&quot;,default-features = false,features = [&quot;default&quot;, &quot;std&quot;]}
_1 = {package = &quot;alga&quot;,version = &quot;=0.9.2&quot;,default-features = false,features = [&quot;default&quot;, &quot;std&quot;]}
# 略
_25 = {package = &quot;itertools&quot;,path = &quot;./itertools-0.8.1&quot;,default-features = false,features = [&quot;default&quot;, &quot;use_std&quot;]}
# 略
_84 = {package = &quot;regex&quot;,path = &quot;./regex-1.3.1&quot;,default-features = false,features = [&quot;aho-corasick&quot;, &quot;default&quot;, &quot;memchr&quot;, &quot;perf&quot;, &quot;perf-cache&quot;, &quot;perf-dfa&quot;, &quot;perf-inline&quot;, &quot;perf-literal&quot;, &quot;std&quot;, &quot;thread_local&quot;, &quot;unicode&quot;, &quot;unicode-age&quot;, &quot;unicode-bool&quot;, &quot;unicode-case&quot;, &quot;unicode-gencat&quot;, &quot;unicode-perl&quot;, &quot;unicode-script&quot;, &quot;unicode-segment&quot;]}
# 略
_107 = {package = &quot;version_check&quot;,version = &quot;=0.9.1&quot;,default-features = false,features = []}
_108 = {package = &quot;whiteread&quot;,version = &quot;=0.4.4&quot;,default-features = false,features = []}
</code></pre>
<p>具体的な動作は以下の通りです。</p>
<ol>
<li>現在のdependency graph上の<code>atcoder-rust-base</code>から<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#platform-specific-dependencies">現在のプラットフォームに適合する</a>、<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies">normal-dependency</a>のみで繋がれた部分グラフを求める。
そしてその節点から<code>atcoder-rust-base</code>を除いたクレートを得る。
またコマンドラインオプションで<code>-d</code>, <code>--depth</code>が指定されている場合さらにそのうちの一部に絞る。
<code>-d 1</code>を指定したならば<code>Cargo.toml</code>の<code>[dependencies]</code>にあるものだけになる。</li>
<li>コマンドラインオプションの<code>&lt;dir&gt;</code>で指定された場所に1.のうちdev-dependencyを含むもののためのワークスペースを一つ、以下の手順で作成する。
<ul>
<li>対象のクレートについて、<code>$CARGO_HOME/registory/src</code>に展開されている<code>.crate</code>ファイルの中身をコピーする。</li>
<li>このコピーしたクレートをworkspace membersとして<code>Cargo.toml</code>を作成する。
このときダミーの<code>dependencies</code>として元のnormal-dependencyとdev-dependencyをバージョンとフィーチャを指定する。</li>
<li><code>Cargo.lock</code>を<code>atcoder-rust-base</code>のもので上書きする。これで大体は元のバージョンが再現できる。</li>
</ul>
</li>
<li>1.のうちdev-dependencyを含まないものは<code>atcoder-rust-base</code>上で直接テストを実行する。</li>
<li>2.で作ったワークスペース上でテストを実行する。</li>
</ol>
<p>ワークスペースを一つにまとめることには以下の問題があり、ワークスペースを分割することで軽減できそうですがどうせ厳密なバージョン, フィーチャの保存は無理だしビルド時間と消費するディスク容量を激増させてまで分割するべきではない、と考えたため一つにまとめてしまいました。</p>
<ol>
<li>同一の名前のpackageはworkspace memberとしては共存できない</li>
<li>既存のpackageのminor, patch versionの増加</li>
<li>オフになっていたフィーチャの有効化</li>
</ol>
<h2><a class="header" href="#クレートのコンパイル" id="クレートのコンパイル">クレートのコンパイル</a></h2>
<p>クレートをコンパイルしましょう。
以下のコマンドを実行します。</p>
<pre><code class="language-console"># cd $RUST_HOME/lib
# cargo build --release
</code></pre>
<p>コンパイルに成功すると以下のように表示されます。</p>
<pre><code class="language-console"># cargo build --release
...（中略）...

Finished release [optimized] target(s) in 1m 39s
$
</code></pre>
<p><code>*.rlib</code>ファイルが作られていることを確認します。
以下のコマンドを実行します。</p>
<pre><code class="language-console">$ find target/release/deps/ -type f | egrep -c '\.(rlib|so)$'
66
# ↑ 上の数字を確認
</code></pre>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#オプションクレート検索パス生成ツールのインストール" id="オプションクレート検索パス生成ツールのインストール">（オプション）クレート検索パス生成ツールのインストール</a></h1>
<p><strong>Note:</strong> この作業は実際のビルドに<code>rustc</code>を利用する場合で、クレート検索パスを指定するコンパイルオプションをツールで生成する場合に必要となります。実際のビルドで<code>cargo</code>を利用する場合と<code>cargo build -v</code>などの出力を元にしてクレート検索パスを指定するコンパイルオプションを手書きする場合などはツールは不要です。</p>
<p>このページでは<code>rustc</code>のコマンドライン・オプションを生成するツールである<code>rustc-dep-option-generator</code>のインストール手順を説明します。
このツールはRustで書かれています。</p>
<h2><a class="header" href="#依存ソフトウェアのインストール-1" id="依存ソフトウェアのインストール-1">依存ソフトウェアのインストール</a></h2>
<p>ツールが依存するシステムライブラリをインストールします。</p>
<pre><code class="language-console">$ sudo apt update
$ sudo apt install -y libssl-dev
</code></pre>
<p>なお<code>libssl-dev</code>は<code>rustc-dep-option-generator</code>が<code>cargo</code>をライブラリとして用いているために必要ですが、このツールではその機能は使いません。ツール実行時のネットワーク・アクセスは不要です。</p>
<h2><a class="header" href="#ツールのインストール" id="ツールのインストール">ツールのインストール</a></h2>
<p><code>cargo install</code>コマンドでインストールします。
以下のコマンドを実行すると、GitHubのリポジトリからツールのソースコードがダウンロードされ、ビルドが実行されます。
ビルドに成功すると、生成された実行ファイルが<code>$CARGO_HOME/bin</code>配下にインストールされます。</p>
<pre><code class="language-console">$ sudo -i

# whoami
root

# cargo install --git https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git
</code></pre>
<p>インストールの成功時は以下のように表示されます。</p>
<pre><code class="language-console"># cargo install --git https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git
    Updating git repository `https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git`
  Installing rustc-dep-option-generator v0.2.0 (https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git#...)
    Updating crates.io index
  Downloaded failure v0.1.5
   ...（中略）...

   Compiling cargo v0.35.0
   Compiling rustc-dep-option-generator v0.2.0 (https://github.com/rust-lang-ja/atcoder-rustc-dep-option-generator.git#...)
    Finished release [optimized] target(s) in 4m 28s
  Installing /usr/local/lib/rust/cargo/bin/rustc-dep-option-generator
</code></pre>
<h2><a class="header" href="#インストール後の動作確認-1" id="インストール後の動作確認-1">インストール後の動作確認</a></h2>
<p>ツールが動作することを確認しましょう。
以下のコマンドを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行
$ which rustc-dep-option-generator
/usr/local/lib/rust/cargo/bin/rustc-dep-option-generator

$ echo $RUST_HOME
/usr/local/lib/rust

$ rustc-dep-option-generator --help
rustc-dep-option-generator 0.2.0
rust-lang-ja Developers
A program to generate Rust compiler options to locate prebuilt crates.

USAGE:
    rustc-dep-option-generator [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --manifest-path &lt;PATH&gt;    Path to Cargo.toml
        --format &lt;FORMAT&gt;         Output format [default: shell]  [possible values: shell, json]

$ RUST_LIB=${RUST_HOME}/lib
$ rustc-dep-option-generator
--extern aho_corasick=/usr/local/lib/rust/lib/target/release/deps/libaho_corasick-aa47a24abbe125fb.rlib
--extern alga=/usr/local/lib/rust/lib/target/release/deps/libalga-8879e1bae3df17da.rlib
...（中略）...
--extern jemallocator=/usr/local/lib/rust/lib/target/release/deps/libjemallocator-f83210f5bd62bec7.rlib
-L dependency=/usr/local/lib/rust/lib/target/release/deps

## ↑ errorの文字が表示されなければOK
##
## エラーの例
## error: failed to find appropriate path for aho-corasick

$ echo $?
0   # 0ならOK
</code></pre>
<p>これでインストール作業は終了です。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コンパイルコマンドと実行コマンド" id="コンパイルコマンドと実行コマンド">コンパイルコマンドと実行コマンド</a></h1>
<p>このページではジャッジサーバでユーザプログラムをコンパイルし、実行するためのコマンドを説明します。</p>
<ul>
<li><a href="atcoder-env/./compiling-and-running-using-rustc.html">rustcを利用する</a></li>
<li><a href="atcoder-env/./compiling-and-running-using-cargo.html">cargoを利用する</a></li>
</ul>
<h1><a class="header" href="#rustc-ファイルレイアウトとコンパイルの流れ" id="rustc-ファイルレイアウトとコンパイルの流れ">[rustc] ファイルレイアウトとコンパイルの流れ</a></h1>
<p>選手がRustプログラムを提出すると、その内容がジャッジサーバ上のファイルシステムに書き出されます。
ジャッジサーバがどのような設計になっているかわからないので、ここでは仮にLinuxユーザのホームディレクトリ配下に<code>WORKAREA</code>という作業用の一時ディレクトリができるものとします。</p>
<p>Rustプログラムは<code>WORKAREA</code>の<code>main.rs</code>に書き出すようにジャッジサーバを設定してください。</p>
<pre><code class="language-console">$HOME             # ユーザのホームディレクトリ
└-- WORKAREA      # ジャッジ用の一時ディレクトリ
    └-- main.rs   # ユーザプログラム（提出されたプログラム）のソースコード
</code></pre>
<p><code>WORKAREA</code>に<code>cd</code>で移動して、後述のコンパイルコマンドを実行します。
すると以下のことが行われ<code>main</code>という名の実行ファイルが生成されます。</p>
<ol>
<li>プログラムがアセンブリコードに変換されオブジェクトファイルが作られる</li>
<li>オブジェクトファイルがRustの標準ライブラリや<code>${RUST_MOME}/lib/target/release/deps</code>配下に作成しておいた<code>rlib</code>とリンクされる</li>
</ol>
<pre><code class="language-console">$HOME
└-- WORKAREA
    |-- main.rs
    └-- main      # コンパイルとリンクの成果物。実行ファイル
</code></pre>
<h1><a class="header" href="#コンパイルコマンド" id="コンパイルコマンド">コンパイルコマンド</a></h1>
<p>ツールチェインのインストールのページで説明したように、コンパイルを実行するシェルに以下の環境変数が設定されている必要があります。</p>
<pre><code class="language-console">$ echo $RUST_HOME
/usr/local/lib/rust

$ echo $RUSTUP_HOME
/usr/local/lib/rust/rustup

$ echo $CARGO_HOME
/usr/local/lib/rust/cargo

$ echo $PATH
... /usr/local/lib/rust/cargo/bin; ...
</code></pre>
<p>コンパイルコマンドは以下のとおりです。</p>
<pre><code class="language-console">$ cd $HOME/WORKAREA
$ RUST_LIB=$RUST_HOME/lib
$ rustc --edition=2018 -C opt-level=3 \
    $(rustc-dep-option-generator $RUST_LIB/Cargo.toml $RUST_LIB/target/release/deps) \
    main.rs
</code></pre>
<p>なお<code>rustc-dep-option-generator</code>の出力は実行環境やソースには依らず、単に依存クレートの位置のみに依ります。従ってインストール時に先に<code>rustc-dep-option-generator</code>を単体で実行し、その出力を直接コンパイルオプションとして置き換えても問題ありません。こうすると毎回コンパイルのたびにこのツールを実行する必要がありません。</p>
<p>これにより<code>$HOME/WORKAREA</code>ディレクトリに<code>main</code>という名の実行ファイルが生成されます。</p>
<h2><a class="header" href="#コンパイルオプションについて" id="コンパイルオプションについて">コンパイルオプションについて</a></h2>
<p><code>rustc</code>コマンドに渡すコンパイルオプションは、Cargoでデフォルトのreleaseプロファイルを使用した時に、<code>cargo build --release</code>で生成される、ごく一般的なものを使用します。
たとえばバイナリの実行速度を最適化するためのオプションとしては<code>-C opt-level=3</code>だけを指定しています。</p>
<p>もし実行速度を追求するなら<code>-C target-cpu=native</code>のようなオプションを追加することもできます。
しかしAtCoder運営者様から以下のようなお話があったため、今回の言語アップデートでは使用しないことにします。</p>
<p><a href="https://twitter.com/chokudai/status/1138677406984691712">https://twitter.com/chokudai/status/1138677406984691712</a></p>
<blockquote>
<p>もうすぐジャッジアップデートの話を出すけれども、ジャッジの目的は「正解と不正解を分けること」であって、「最速を目指すこと」ではないので、十分に早い言語（C++, Rustなど）では、過剰な最適化とかを含めた提案はRejectすることがあるかも。</p>
</blockquote>
<p><a href="https://twitter.com/chokudai/status/1138677959059943424">https://twitter.com/chokudai/status/1138677959059943424</a></p>
<blockquote>
<p>といいつつ、言語間の差を減らすために「C++はO2とか付けない！」みたいな滅茶苦茶なことを言い出すつもりは全くなくて、「AtCoder環境がちょっと変わると動かなくなる」みたいな最適化は受け入れない、くらいの話です。</p>
</blockquote>
<p>通常形式のコンテスト（アルゴリズム系）では最速を目指すことには意味がありません。</p>
<p>一方、マラソン系のコンテストでは、たとえ数パーセントでも速度が向上するなら嬉しいことも多くあります。
AtCoderでは将来マラソン系のコンテストもRatedにする可能性があり、その際にコンパイルオプションを追加するか検討できるかもしれません（<a href="https://twitter.com/tatsuya6502/status/1140049804082311168">参考</a>）</p>
<h2><a class="header" href="#コンパイルコマンドが動作することの確認" id="コンパイルコマンドが動作することの確認">コンパイルコマンドが動作することの確認</a></h2>
<p>コンパイルコマンドが動作することを確認しましょう。
クレートのインストールに使用したCargoプロジェクトには、それらのクレートを使用する簡単なサンプルコードが含まれています。</p>
<p>以下の方法でコンパイルできます。</p>
<pre><code class="language-console">## 一般ユーザで実行

## 作業用のディレクトリを作成する

$ mkdir $HOME/WORKAREA
$ cd $HOME/WORKAREA

## サンプルコードの入ったソースファイル（2つある）をコピーする

$ RUST_LIB=$RUST_HOME/lib

$ cp -p $RUST_LIB/src/main.rs .
$ cp -p $RUST_LIB/tests/test_jemallocator.rs .

## サンプルコードをコンパイル、リンクする

$ rustc --edition=2018 -C opt-level=3 $(rustc-dep-option-generator) main.rs

$ rustc --edition=2018 -C opt-level=3 $(rustc-dep-option-generator) test_jemallocator.rs
</code></pre>
<p>コンパイルとリンクに成功すると実行ファイルが作られます。</p>
<pre><code class="language-console">$ file main
main: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),
  dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0,
  BuildID[sha1]=50373af3038c60f2a3e7a162b310e5226b08c8a9,
  with debug_info, not stripped

$ file test_jemallocator
test_jemallocator: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),
  dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0,
  BuildID[sha1]=31b718908ebf067f4b1161b1dc5cf679f012ad7f,
  with debug_info, not stripped
</code></pre>
<h1><a class="header" href="#実行コマンド" id="実行コマンド">実行コマンド</a></h1>
<p>実行ファイルを実行するコマンドは以下のとおりです。</p>
<pre><code class="language-console">$ cd $HOME/WORKAREA
$ ./main
</code></pre>
<h2><a class="header" href="#実行コマンドが動作することの確認" id="実行コマンドが動作することの確認">実行コマンドが動作することの確認</a></h2>
<p>実行コマンドが動作することを確認しましょう。
先ほど作成した実行ファイルを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行

$ cd $HOME/WORKAREA

$ ./main
...

## いろいろなメッセージが表示されるが、テスト用の出力なので内容は確認しなくてよい
## 終了コード0で終了したことだけを確認すればOK

$ echo $?
0

$ ./test_jemallocator
...

## こちらも終了コード0で終了したことだけを確認すればOK
$ echo $?
0
</code></pre>
<p>AtCoder運営者向けの情報は以上となります。
内容について質問などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<h1><a class="header" href="#cargo-ファイルレイアウトとコンパイルの流れ" id="cargo-ファイルレイアウトとコンパイルの流れ">[cargo] ファイルレイアウトとコンパイルの流れ</a></h1>
<p>選手がRustプログラムを提出すると、その内容がジャッジサーバ上のファイルシステムに書き出されます。
ジャッジサーバがどのような設計になっているかわからないので、ここでは仮にLinuxユーザのホームディレクトリ配下に<code>WORKAREA</code>という作業用の一時ディレクトリができるものとします。</p>
<p>まずは先ほど依存クレートをコンパイルするのに利用したプロジェクトのディレクトリを、そっくり<code>WORKAREA</code>内に丸ごとコピーしてください。依存クレートをコンパイルするのに利用したプロジェクトは、本書の通りにセットアップした場合<code>/usr/local/lib/rust/lib</code>となっているはずです。</p>
<pre><code class="language-console">$HOME                      # ユーザのホームディレクトリ
└-- WORKAREA               # ジャッジ用の一時ディレクトリ
    └-- lib                # 全部入りプロジェクトをまるまるコピーしたもの
        |-- main.rs        # ユーザプログラム（提出されたプログラム）のソースコードに置き換える
        |-- Cargo.toml
        └-- target
            └-- release
                |-- deps   # (外部クレートのコンパイルキャッシュ)
                └-- atcoder-rust-base # コンパイル、リンク済みの実行ファイル
</code></pre>
<p>そして、この<code>WORKAREA/lib/main.rs</code>をユーザーが入力したファイルにそっくりそのまま置き換えます。</p>
<p>以上でCargoプロジェクトが整いました。</p>
<h1><a class="header" href="#コンパイルコマンド-1" id="コンパイルコマンド-1">コンパイルコマンド</a></h1>
<p>ツールチェインのインストールのページで説明したように、コンパイルを実行するシェルに以下の環境変数が設定されている必要があります。</p>
<pre><code class="language-console">$ echo $RUST_HOME
/usr/local/lib/rust

$ echo $RUSTUP_HOME
/usr/local/lib/rust/rustup

$ echo $CARGO_HOME
/usr/local/lib/rust/cargo

$ echo $PATH
... /usr/local/lib/rust/cargo/bin; ...
</code></pre>
<p>コンパイルコマンドは以下の通りです。</p>
<pre><code class="language-console">$ cd $HOME/WORKAREA/lib
$ cargo build --release --offline
</code></pre>
<p>すると<code>$HOME/WORKAREA/lib/target/release</code>ディレクトリに<code>atcoder-rust-base</code>という名前の実行ファイルが生成されます。</p>
<h2><a class="header" href="#コンパイルオプションについて-1" id="コンパイルオプションについて-1">コンパイルオプションについて</a></h2>
<p>Cargoを利用する場合、ネットワーク接続がない環境でも安定して動作させるため、<code>--offline</code>オプションを利用します。それ以外は、通常のRustプロジェクトのビルドと同様です。</p>
<h2><a class="header" href="#コンパイルコマンドが動作することの確認-1" id="コンパイルコマンドが動作することの確認-1">コンパイルコマンドが動作することの確認</a></h2>
<p>実際のコンテストでは<code>WORKAREA/lib/main.rs</code>ファイルをユーザーの入力でそっくり置き換えて実行するのですが、置き換える前の<code>WORKAREA/lib/main.rs</code>には各依存クレートに対応する簡単なテストコードが含まれています。<a href="atcoder-env/./installing-rust-crates.html#%E3%82%AF%E3%83%AC%E3%83%BC%E3%83%88%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88">クレートをインストールした際に確かめたのと同様の方法で</a>このファイルがコンパイルできることを確かめましょう。</p>
<p>まずは動作の確認です。</p>
<pre><code class="language-console">$ cargo test --release
   Compiling atcoder-rust-base v0.1.0 (...)
    Finished release [optimized] target(s) in 7.31s
     Running target\release\deps\...

running 11 tests
test test_ascii ... okYes
Yes

test test_bitset_fixed ... ok
test test_modtype ... ok
test test_ordered_float ... ok
test test_permutohedron ... ok
test test_itertools ... ok
test test_rand_family ... ok
test test_proconio ... ok
test test_regex ... ok
test test_rustc_hash ... ok
test test_superslice ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>多少表示されるテストの個数は異なるかもしれませんが、一番下の行が<code>test result: ok.</code>で<code>0 failed;</code>となっていれば問題ありません。</p>
<p>続いてコンパイルができることを確認します。</p>
<pre><code class="language-console">$ cargo build --release --offline
(...略...)
    Finished release [optimized] target(s) in 0.86s
</code></pre>
<p>上のように<code>Finished</code>が出力されれば、実行可能バイナリが<code>$HOME/WORKAREA/lib/target/release/atcoder-rust-base</code>に生成されているはずです。</p>
<h2><a class="header" href="#実行コマンドが動作することの確認-1" id="実行コマンドが動作することの確認-1">実行コマンドが動作することの確認</a></h2>
<p>実行コマンドが動作することを確認しましょう。
先ほど作成した実行ファイルを実行します。</p>
<pre><code class="language-console">## 一般ユーザで実行

$ cd $HOME/WORKAREA

$ target/release/atcoder-rust-base
...

## いろいろなメッセージが表示されるが、テスト用の出力なので内容は確認しなくてよい
## 終了コード0で終了したことだけを確認すればOK

$ echo $?
0
</code></pre>
<p>AtCoder運営者向けの情報は以上となります。
内容について質問などがありましたら、<a href="https://github.com/rust-lang-ja/atcoder-rust-resources/issues">GitHub Issue</a>などでご連絡ください。</p>
<!-- -*- coding:utf-8-unix -*- -->
<h1><a class="header" href="#コントリビュータ" id="コントリビュータ">コントリビュータ</a></h1>
<p><strong>TODO</strong> このページは書きかけです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
