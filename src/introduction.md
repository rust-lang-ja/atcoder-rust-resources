<!-- -*- coding:utf-8-unix -*- -->

# はじめに

**TODO** このページは書きかけです。

本書はAtCoderのコンテストにRustで参加するためのガイドブックです。


## AtCoderとは？

AtCoderは、オンラインで参加できるプログラミングコンテスト(競技プログラミング)のサイトです。リアルタイムのコンテストで競い合ったり、約3000問のコンテストの過去問にいつでも挑戦することが出来ます。 ([AtCoderのトップページ](https://atcoder.jp/)より引用)

**Note:** 競技プログラミングはプログラミングで解決できるような問題をなるべく早く正確に解く競技です。競技プログラミングについてよく知らないが興味があるという方は、インターネット上に初心者向けの詳しい情報がたくさんありますので検索してみてください。AtCoderで開催されているものでは、大きく分けて二種類あります。

- 与えられる問題に対して、その解を出力するようなプログラムを書く競技 (アルゴリズム系)
    - 定期開催のもの: AtCoder Beginner Contest (ABC), AtCoder Regular Contest (ARC), AtCoder Grand Contest (AGC) があり、難易度は通常 ABC &lt; ARC &lt; AGC です。
    - 定期開催の他、企業によって開かれるコンテストもあります。そういったコンテストで上位成績をとると、その企業への就職、インターン、アルバイトなどで多少優遇されることがあります (コンテストによります) 。
    - 例: 「整数`N`が与えられます。`N`以下の正整数から等確率に1つを選ぶとき、それが奇数になる確率を求めなさい」 (AtCoder Beginner Contest 142 A問題)
    - 例: 「`N`人の身長が与えられます。`K`cm以上の人の人数を出力してください」 (AtCoder Beginner Contest 142 B問題)
- 与えられる問題に対して、少しでも良い解を出力するようなプログラムを書く競技 (マラソン系)
    - 定期開催のものはまだありません。企業が自社の取り組みやそこでの課題をテーマに出題することが多いようです。
    - 例: 「ある観測データが与えられるので、可能な限り圧縮するプログラムとそれを解凍するプログラムを書いてください」 (Wethernews Programming Competition)


## なぜRustなのか？

AtCoderで使える言語は非常にたくさんあります。どの言語を使ってもよいですし、問題によって使い分けても構いません。その中でなぜRustを使うのか、そのメリットとデメリットをまとめてみました。できるだけ一般論で比較するよう心がけますが、競技プログラミングにおけるC++人口がそれなりに多いことと、Rustはその特性上C++と比較されることが多いので、具体的にC++との比較になっている部分も多くあります。

### メリット

#### 高速である

AtCoder含め、競技プログラミングでは「実行時間制限」とよばれるものがあります。この時間内にプログラムの実行が終わらないと「TLE (Time Limit Exceeded)」という判定が付いて誤答扱いとなります。多くの場合は想定されている解法であれば多少の余裕をもって解けるように設定されていますが、非常にたくさんの言語が使える都合上全ての言語で公平になるようにはできません。遅い言語に合わせて設定すると速い言語では強引な解法でゴリ押しできてしまうことがありますし、速い言語に合わせると遅い言語では想定されている解法でも通せないということになります。いずれにせよ、基本的には速い言語であるほうが計算時間的には有利です。 (もちろん遅い言語と言われるものにも、例えば書き易さであったり、ライブラリが充実していたり、なにかしらのメリットがあるはずです。どちらかが絶対的に有利ということではありません。)

Rustは最速と言われるC/C++並みに速いとされていますので、(少なくともAtCoderでは) 速度面で不利になることはないと言えるでしょう。

#### 信頼性が高い

信頼性は、ここではRustの[公式トップページ](https://www.rust-lang.org/)に倣いメモリ安全性、スレッド安全性、バグの起こしにくさであるとします。競技プログラミングで特に大事になってくるのはメモリ安全性とバグの起こしにくさです。

> **Reliability**
> Rust’s rich type system and ownership model guarantee memory-safety and thread-safety — and enable you to eliminate many classes of bugs at compile-time.

これは様々なプログラミング言語が様々なアイデアで対処している部分です。たとえばメモリの確保と解放を正しく行うために、C++であればスマートポインタやコンテナを用意したり、他の言語ではガベージコレクタという実行時の機構を用意したりしています。RustでもC++のスマートポインタやコンテナと同様なものを用意し、自分でメモリの確保と解放を行わなくてよいようにできています。ガベージコレクタを利用すると確かに安全でメモリ管理に関してほとんど何も考えなくてよいものの、そのためにほとんどのデータをヒープに置いて参照経由で扱わなければならず、実行速度にも多少影響します。かといってC++のスマートポインタやコンテナは間違った使い方が簡単にできてしまいます。特にイテレータはコレクションに対する操作を行うための標準的なツールにもかかわらず実質的に単なるポインタと同様なので、しばしば無効なイテレータが発生します。例えば (少々意図的な例ですが) 次のように簡単に問題を起こせてしまいます。

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std::string_literals;
int main() {
    std::vector<std::string> v = {"hello"s, "world"s};
    v.shrink_to_fit();
    for (auto const &i: v) {
        if (i == "hello") v.push_back("c++"s); // イテレータを無効化してしまう
        // 未定義動作なので、プログラム全体が何を起こすか分からない
        std::cout << i << std::endl;
    }
}
```

このようなことはRustではコンパイルエラーとしてコンパイル時に検出されます。

```rust,ignore
let mut v = vec!["hello", "world"];
for &i in &v {
    if i == "hello" {
        v.push("rust");
        // E0502: cannot borrow `v` as mutable because it is also borrowed as immutable
        // 4 | for &i in &v {
        //   |           --
        //   |           immutable borrow occurs here
        //   |           immutable borrow later used here
        // 5 |     if i == "hello" {
        // 6 |         v.push("rust");
        //   |         ^^^^^^^^^^^^^^ mutable borrow occurs here
    }
    println!("{}", i);
}
```

また、複雑なアルゴリズムにバグはつきものです。例えば、添字計算をしていてちょっとした書き間違いで配列のサイズを超えたところを参照してしまったといったことは度々起こりえます。こういうとき、例えばC/C++では配列外参照をしてしまったプログラムがどのように動作するかの保証がなく、`segmentation fault`とだけ表示されて異常終了したり、たまたまうまくいってしまったり、手元で正解するケースがサーバーでは誤答となったりし得ます。こういったよく分からない動作が起きてしまうとバグの原因特定が難しくなったり無関係なところを原因と思い込んだりしてしまい、デバッグにかなりの時間を費やしてしまうこともしばしばあります。この配列外参照の例ではRustは必ずエラーを起こしますし、どこで起こしたかも表示してくれます。それが自分のコードでない場合でも (`-g`オプション付きでビルドされたかCargoでデバッグビルドされたバイナリであれば) バックトレースを表示させることで呼出元となる自分のコードを特定できます。

```rust,should_panic
let x = vec![1, 2, 3];
let y = 3;
let _z = x[y]; // 配列外参照!
```

```text
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3', ...
stack backtrace:
  (...中略...)
  16: alloc::vec::{{impl}}::index<i32,usize>
             at ...
  17: test::main
             at .\test.rs:4
  (...中略...)
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

#### 多くの問題をコンパイル時に発見できる

RustはC/C++並みの速度を確保するため、実行時にやらなければいけないことをなるべく減らす方針の言語です。たとえば先ほど触れたように、多くの言語にあるガベージコレクタがありません。それだけならばC++と変わりないのですが、速度と安全性を両立させるためにRustではできるだけ多くのことをコンパイル時に確認する仕組みになっています。C++が受け入れてしまうような危険なコードもコンパイルエラーにします。

それ以外にも、例えば整数型同士の暗黙の型変換がない (例え`u8`から`u32`であっても) こともある種のミスを防ぐのに役立ちます。たとえばC++で総和をとるために`accumulate()`関数を利用する際、気をつけなければオーバーフローしないはずのところでオーバーフローを起こしてしまいます (もし符号付き整数型であったなら未定義動作にもなってしまいます) 。

```cpp
#include <iostream>
#include <limits>
#include <numeric>
#include <vector>
int main() {
    // long long で表せる最大値を`large`とする。
    long long large = std::numeric_limits<long long>::max();

    std::vector<long long> s = {large};

    // sには`large`しか入っていないので、総和は普通に`large`になるはず。ところが
    // 総和の型をint型だと思って計算してしまいオーバーフローを起こしてしまう。特
    // に何のエラーもなし。
    std::cout << std::accumulate(s.begin(), s.end(), 0) << std::endl;

    // 正しくは以下の通り。
    std::cout << std::accumulate(s.begin(), s.end(), 0ll) << std::endl;
}
```

Rustではこのようなことは最初から型の不一致によりコンパイルエラーとなります。

```rust,ignore
let s = vec![std::i64::MAX];
let x: i32 = s.into_iter().sum();
// E0277: the trait bound `i32: std::iter::Sum<i64>` is not satisfied
// 3 | let x: i32 = s.into_iter().sum();
//   |                            ^^^ the trait `std::iter::Sum<i64>` is not implemented for `i32`
```

ジェネリクスとトレイトの仕組みも強力です。たとえばジェネリックな関数が型変数`T`をもつとき、この`T`のとりうる型を特定のトレイト (＝機能一覧) を実装しているものだけに制限することができます。逆に`T`に対してできることはその特定のトレイトが定める機能のみです。従って、一度コンパイルが通った関数はその制約を満たす限りのどのような`T`を与えても関数の内部でコンパイルエラーとなることはありません。特にライブラリを整備するにあたってはこれはとてもありがたいことです。実際に使ってみなくても、コンパイルさえ通れば、将来的に作られうるどんなユーザー定義型を与えようともその関数が正しく呼び出せることが保証されます。C++のテンプレートなどでは実際に具体的な型を与えて始めて様々な検証をするので、使う段階になってからでないとエラーが発見できません。このことは、後述するコンパイルエラーの分かりやすさにも繋がっています。

#### コンパイルエラーが分かりやすい

これは少々主観的な話になるのかもしれませんが、Rustのコンパイルエラーは読みやすく分かりやすいという評判があります。実際にコンパイルエラーが発生したとき、まずエラーが起きた場所はもちろんとして、エラーが関連する他の場所 (例えば以前に借用された場所など) などをアスキーアート的な手法で視覚的に分かりやすく表示してくれます。さらに、なぜそれが間違っているのか/それをどのように修正することができるかのヒントが提示されることもあります。例えば、先ほどのエラー全体は次のようになっていました。

```console
error[E0277]: the trait bound `i32: std::iter::Sum<i64>` is not satisfied
--> (filename):3:32
|
3 |     let x: i32 = s.into_iter().sum();
|                                ^^^ the trait `std::iter::Sum<i64>` is not implemented for `i32`
|
= help: the following implementations were found:
            <i32 as std::iter::Sum<&'a i32>>
            <i32 as std::iter::Sum>

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
```

先ほど少し触れたように、トレイト/ジェネリクスの仕組みによりエラーの所在が明確化されています。関数が呼び出せないのは引数に関数が設定した制約を満たさないものを与えているからだと分かります。動的型付け言語やC++のテンプレートでは、仕組み上実際に実行または実体化してみなければエラーの存在が分かりませんので、与えられた引数が関数の求める条件を満たしていなかったのか関数の方に根本的な書き間違いがあるのかがインタプリタ/コンパイラには分かりません。必然的に実際にエラーを起こしたライブラリの内部の実装部分を指し示しながら、ここで呼び出されていて、ここで呼び出されていて、...と辿っていくしかなく、しかもそのうちのどれが悪いのかが分からないので関係がありそうなところを全て表示していくしかありません。

一部のエラーには詳細な説明が用意されており、`rustc --explain (エラーコード)`とすることにより、そのエラーが何を言っているのか/どういうコードでそのエラーが発生するのかなどをもりこんだ詳細な解説を読むこともできます。たとえば上のエラーの`E0277`にも用意されています。

``````console
$ rustc --explain E0277
You tried to use a type which doesn't implement some trait in a place which
expected that trait. Erroneous code example:

```
// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func<T: Foo>(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}
```
(以下略)
``````

#### 抽象化のための機能を数多く備えている

Rustにはトレイトやジェネリクスの他にも抽象化に役立つ多数の機能を提供しています。

TODO: ゼロコスト抽象化（_zero-cost abstraction_）

- block expression
    - 地味ですが嬉しいです。
- 強力な型推論
    - Hindley/Milnerをベース(TODO: ?)にした賢い型推論器を持ちます。
      いくつかの制限がありますが、基本的に推論されて欲しいときにはきちんと推論してくれます。
- [代数的データ構造](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html)
    - Rustの列挙型（`enum`）は各バリアントにパラメータを持てます。
      Rustにはいわゆる『オブジェクト指向言語』のような継承の仕組みを持ちませんが列挙型とトレイトにより不要です。
      dynamic dispatchを行なう機会もそう多くはありません。
- [パターンマッチング](https://doc.rust-lang.org/book/ch18-00-patterns.html#patterns-and-matching)
    - Rust 1.26で[slice pattern](https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html)が追加されたり1.39で[`if`の制限の取り払われたり](https://github.com/rust-lang/rust/pull/63118/)して、ML系言語とかのそれに近づいてきました。
- [**衛生的**マクロ](https://doc.rust-lang.org/book/ch19-06-macros.html)
    - 構文木が壊れるのはもちろん、識別子が衝突する心配もありません。
      安全性を保ったままで色々なことを可能にします。
      ボイラープレートもサクっと圧縮できます。
      この後述べるRustのデメリットはマクロで解決できるものが以外と多いです。

### デメリット

#### 現れる概念が比較的難しい

先に見たように、Rustでは、いままで他の言語ではコンパイラが検証していなかったようなことをコンパイル時に検証します。そのためにRustでは所有権や借用をはじめとする独特の概念が導入されており、それらの概念の理解そのものが難しいとされることも多いようです。これらの概念が課す多数のルールがなぜ存在するのかを理解することは、仕組みをある程度理解していなければ難しいものです。

たとえば要素への参照をもったまま`Vec`本体の可変参照をとることはできませんが、これは可変参照と共有参照は同時に存在できないというルールからです。ではなぜこのようなルールがあるのでしょうか。たとえば`Vec`に要素を追加するとキャパシティが足りないときにメモリの再確保とデータの移動が行われるので、無効な参照が生み出せてしまうからです。しかしこういった事情を知らないと、単にRustがよく分からない制約を課してくるだけの書きにくい言語だと感じてしまうかもしれません。一方でこの難しさを隠せている言語もあります。たとえばJavaやC#などオブジェクトを参照で扱うような言語では、要素への参照を得ても単にそのオブジェクトへの参照が一つ増えるだけで、可変長配列の領域そのものへの参照を得るわけではないということもあるかもしれません。そのような言語では、要素そのものは可変長配列が管理するメモリ上にあるわけではないので、要素への参照をもったまま可変長配列を伸ばしても問題は起こりません。そのかわり、おそらく別の部分の犠牲 (アクセスに必ず参照を介することのコストであったり、参照型と値型の挙動の違いによる難しさであったり) があります。

Rustが課すルールにも理由がありますので、そういった事情について意識的に考えることは他の言語や競技プログラミング以外の文脈でも活きる有意義なものではあると思います。単にAtCoderである程度の競技プログラミングをするだけであれば、C#やJavaといった言語でもほぼ正解できるよう調整されているようなので、どちらを取るかは好みといっていいかもしれません。

#### 素早く書くことにはあまり向かない仕様

Rustの安全指向や標準ライブラリの設計方針などは、時間をかけて大規模なプログラムを書くときや堅牢なプログラムを書くときには非常に役に立ちます。一方で競技プログラミングでは、一般のプログラミングと異なり、次のような特徴があります。

- 早くプログラムを完成させることが重要
- 入力のフォーマットや扱う値の範囲・個数などが定まっている
- スレッドを起動してやりとりするようなことは通常ない
- 後日提出したプログラムを見直したり保守することは通常ない (ライブラリを除く)

したがって、Rustの様々な設計は、必要以上に煩雑に感じることがあります。例えば、Rustでの競技プログラミングを始めようとした方で、標準入力をとるのがとても面倒で挫折し (かけ) た、という方も度々見かけます。例えば、空白区切り二つの整数を読み取ってその和を計算するプログラムは、工夫をしなければ次のようになります。

```rust,no_run
fn main() {
    let (a, b) = {
        let mut s = String::new();
        std::io::stdin().read_line(&mut s).unwrap();
        let mut iter = s.split_whitespace().map(|i| i.parse::<i32>().unwrap());
        (iter.next().unwrap(), iter.next().unwrap())
    };

    println!("{}", a + b);
}
```

「二つの空白区切りの数字を読むだけでこれほど多くのコードが必要なのか」と思われるかもしれませんが、こうなっているのには次のような設計があります。

- 空白区切りの入力を任意の型の値として読み込むことができない。
    `std`には整数を読む機能などはなく、かならず一行単位 (`read_line()`) または全体 (`read_to_string()`) を文字列として読んでから処理する必要があります。なお`read_to_string()`を使うときは、`use std::io::Read;`が必要であることと、手元でテストするときにEOF (`Ctrl + D` (macOSやLinux) または`Ctrl + Z` (Windows)) を入力するまで入力が終了しないこと、に注意が必要です。
- 入力はバッファをとって、そこに書き込む。
    `read_line(&mut s)`の部分にあたります。入力を`String`に入れて返す関数よりも、バッファを受けとって書き込む方式の方が、必要に応じてバッファを事前にアロケートしておける分、パフォーマンス的には柔軟なのです。とはいえ競技プログラミングでは高々O(log n)回のリアロケーション（この挙動はドキュメント化されていないみたいですが）にかかるコストを気にする必要はないと思われます。
- イテレータを上手に扱う必要がある。
    受け取った文字列を空白区切りにするためには`split_whitespace()`という関数を使いますが、これはイテレータを返します。その各要素を整数に変換するために`map()`と`parse()`関数を使いますが、変換先の型を指定するために`parse::<i32>()`などの書き方を使います。[`itertools`](https://crates.io/crates/itertools)を使えば[Pythonの`a, b = iter`のようにイテレータを直接分解するような書き方ができますが](https://docs.rs/itertools/0.8.2/itertools/trait.Itertools.html#method.next_tuple)、`std`だけだと一つずつ`next()`で要素を取り出してタプルを作る必要があります。
- `std`を含む各ライブラリは大抵明示的なエラーハンドリングを要求する。
    - 何かの理由で標準入力が読み込めない状態になるかもしれません。整数ではない入力を整数にしようとするかもしれません。イテレータの要素が足りないかもしれません。こういったものをRustでは[`Option`](https://doc.rust-lang.org/stable/std/option/enum.Option.html)や[`Result`](https://doc.rust-lang.org/stable/std/result/enum.Result.html)で表現します。[`?`](https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html)を使えば視認性を損ねることはない（むしろコードを俯瞰するときのの助けになる）ですが競技プログラミングでは`unwrap()`を使うことになるでしょう。これはエラーが起きたならパニック（i.e. `RE`） するという乱暴なものですが、入力の形式が決まっている以上エラーになるのは読み間違えたか書き間違えたときのみでしょう。
    - ただ例外はいくつかあります。
      例えば[`Index`](https://doc.rust-lang.org/stable/std/ops/trait.Index.html)で境界外アクセスしたときやメモリが足りずにアロケーションに失敗したとき、[`println!`が失敗したとき](https://doc.rust-lang.org/std/macro.println.html#panics)にパニックします。
      このように『失敗するとパニックする』ものはその条件をドキュメントに`# Panics`という形で書いています。

(TODO: proconioの当落に応じて追記)

他にも、先程少し触れましたが例えば数値型の四則演算や比較を行なうときには基本的に両辺の型が等しくなければいけません。
`i32`と`&'_ i32`を両辺に持って来ることくらいは許されていますが`i32`と`i64`をそのまま足したり比較したりはできません。
片方を明示的に変換する必要があります。
これは型システムの都合等ではなく数値型に対しては意図的に制限されています。

さらにスライスのインデックスは[`usize`及び`usize`の範囲](https://doc.rust-lang.org/stable/std/slice/trait.SliceIndex.html)でなくてはなりません。
`isize`では駄目です。
競技プログラミングでは非負整数として入力される値であっても計算途中では符号付き整数の方が扱いやすいので変換することが多いですが、その場合`arr[(添字の計算式) as usize]`のように`usize`に戻す必要があります。
実際AtCoderの提出のうち、`"as usize"`という部分文字列を持つRustのコードは結構な数が存在します。
地味なところですが、動的計画法など添字を多用するところでは面倒に感じるかもしれません。

一般的には危ないのでコンパイラが許してくれないものの、使い方の制限に照らせば問題ない動作をしたいということもありえます。たとえば[こちら](https://qiita.com/tanakh/items/d70561f038a0ef4f0ff1)では二次元配列 (`Vec<Vec<T>>`) における要素の交換を実装しようとしていますが、同じ要素に対する二つの可変参照を持てないというルールによって普通に実装することができません。競技中に「あ、これがやりたい」と思ったことが必ずしもスムーズに実装できない場合がありえます。

Rustで参加する競技プログラマーの中には、こうした煩雑さを改善するためのマクロやヘルパ関数 (もっと便利に標準入力がとれるようにするなど) を定義し、テンプレート (ひな型) として用意している方もいます。インターネット上で公開されている方もいらっしゃいますし、過去のコンテストでの上位Rust参加者の提出などをのぞいてみると、いろいろと参考になるかもしれません。

#### 標準ライブラリが小さい

Rustは比較的新しい言語ですので、インターネット接続環境を前提にしたパッケージ管理システムCargoを標準で持ちます。このため、言語の成長とクレートやRustエコシステムの成長を分離することを目的に、Rustは標準ライブラリを最低限の抽象化とインターフェースとして位置付け、できるだけ小さく保ち続けてきました。かつて標準ライブラリの一部だったり本体にバンドルされていたライブラリ (`num`, `rand`, `regex` など) を積極的に分離することさえしています。ユーザーはCargoを使えば、使いたいパッケージを[crates.io](https://crates.io)からいつでも自由にダウンロードできます。

(TODO: クレートが導入されたかどうか追記)

#### コンパイル時間が長くなりがち

様々な解析をコンパイル時に行う都合上、コンパイル時間が長めにかかる傾向があります。Rustではコンパイル速度を速くすることはあまり重要視されていません。特に手元で提出をテストする際、外部クレートを利用するならその外部クレートのビルドも実行することになります。二回目以降のビルドではビルドキャッシュを利用するためコンパイルする必要はありませんが、初回の実行では利用する外部クレートによっては数分単位の時間をとられる可能性があります。つまり、素早く書き上げたコードを手元で軽く実行してみることにすら時間をとられてしまい、提出時刻が数分遅れてしまうということがあり得ます。結果的に手元でコンパイルが通るかどうかをチェックする時間すら惜しいとなってしまうと本末転倒です。なお、外部ライブラリを含むパッケージをコンテスト開始前に一回ビルドしておいて、競技時はそのフォルダをコピーして編集するというふうにすれば回避できます。
